<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>老杨说</title>
  
  <subtitle>思考和写作</subtitle>
  <link href="https://jamesyyang.github.io/atom.xml" rel="self"/>
  
  <link href="https://jamesyyang.github.io/"/>
  <updated>2023-05-04T03:30:44.706Z</updated>
  <id>https://jamesyyang.github.io/</id>
  
  <author>
    <name>James Yang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于数字化转型</title>
    <link href="https://jamesyyang.github.io/2023/05/04/thinking-digital-transformation/"/>
    <id>https://jamesyyang.github.io/2023/05/04/thinking-digital-transformation/</id>
    <published>2023-05-04T03:19:08.000Z</published>
    <updated>2023-05-04T03:30:44.706Z</updated>
    
    <content type="html"><![CDATA[<p>对于企业而言，数字化转型早已经是一个绕不开的话题。到底什么是数字化转型？好像很少有人说清楚，今天看到一篇文章，还不错，转给大家看看。</p><span id="more"></span><h2 id="数字化转型到底在转什么？"><a href="#数字化转型到底在转什么？" class="headerlink" title="数字化转型到底在转什么？"></a>数字化转型到底在转什么？</h2><p>“转型”这个词比较好理解，每家公司或多或少都经历过转型。一家公司，不同发展阶段的重心是不一样的，之前的优势可能到现在就是劣势了，为了发展，所以需要不断转型。但是，加了一个定语“数字化”后，传统企业的管理者们就蒙圈了。他们不知道数字化转型到底意味着什么，毕竟数字化是个新东西。</p><p>接下来，我从宏观、中观和微观三个层面分别聊聊我的看法。</p><p><code>首先，从宏观来讲，数字化转型是大势所趋。</code>但是，注意不要把数字化转型中的数字化简单理解为某一种技术，而是应该理解为<code>我们不断地通过技术手段打破空间的限制，使企业可以更方便地从事各种生产或经营活动。</code></p><p>人类社会，从农业化，到工业化、信息化，再到现在的数字化，一共经历了 4 个阶段。这期间有两个规律没变，一是人类<code>通过技术的手段不断地打破空间对活动的限制</code>；另一个是<code>个体的能力因为技术的发展而逐渐变强</code>。</p><p>这几年，很多人喊元宇宙，虽然有时候大家觉得很虚，但这个技术的探索方向我认为没错。它本质是要在虚拟空间里，通过提升协同效率来提升工作效率，让个人不再受地理空间的限制做事。这是顺应趋势的，只是现在的时机还不成熟。</p><p><code>我觉得数字化会让“渠道”发生很大变化。</code>渠道就是你跟所有人的联系方式，无论是 ToC 的企业还是 ToB 的企业都有自己的渠道。回顾一下最近这十年，移动互联网带来的最大变化就是渠道，渠道革命对我们整个的商业形态影响都很大。顺着数字化的方向往后走，将来就是 3D 渠道。渠道不断升级就是数字化技术带来的自然结果。</p><p>渠道的变化，我看到大家鲜有提到，其实是挺重要的。特别是对于传统企业而言。</p><p>另一个趋势是随着技术的发展，每个人的能力都在增强。 就像最近很火的 ChatGPT，它本身就是各种知识封装，借助 ChatGPT 助手，每个人掌握的东西瞬间增加很多。比如更强的对话能力。实际上，随着数字化技术的发展，借助工具，个体的能力也在不断增强，这带来很多变化。它也一定会反映在商业形态上，甚至会改变企业的组织管理和个体的工作方式。</p><p><code>中观层面，在数字化条件下，企业到底应该是什么样的。</code>我们现在的传统工厂，引入了一些先进的设备，但是整体上来讲，工厂并没有完整连接起来。数字工厂是指不仅要给工厂引进新的设备，还要让这些设备通过各种手段能够连接在一起，让整个工厂像数字化系统一样高效运转。</p><p>以前，生产设备上虽然有系统，工作人员还要去车间的机床上看数据，但是，现在人们希望坐在办公室就能看到数据，坐在办公室里就能调配整个生产线。但这只是一小步，如果真正产生作用，你会发现内部的管理应该会发生很大变化，<code>这个时候大家就需要琢磨，我们应该把什么样的业务知识转移到我的业务系统里。</code></p><p>这是我们设计数字化企业时应该考虑的事情。数字化转型绝对不是简单地把一个线下的流程搬到线上去，而是要把业务经验和知识注入到系统。<code>如果能够站在这个视角看问题，等你把所有设备系统连上了，用数据改善或者是改变业务，用数据驱动决策，把业务经验和知识转化成软件里的算法或者功能，把它放到管理系统，管理工厂这件事就变得越来越有效率了。</code></p><p><code>再往微观讲</code>，时代的变化必然会作用到每个人身上，企业对劳动者的技能要求也在发生变化。很多人都跟 ChatGPT 聊过天，聊天的过程中就能发现，如果这个人有很强的结构化思维，善于层层递进，善于用条件约束大模型，以指定的资料要求它分析，那 ChatGPT 产生的结果会比你泛泛地聊天要好。</p><p>泛泛的纯用自然语言提问，就是找了个知识比较丰富的陪聊，那不是真正的生产工具，生产工具是你给他明确的约束条件，他就会产生预期结果。不管是 ChatGPT，还是其它工具，我认为核心能力之一是一个人的结构化思维。在数字工厂里，靠用结构化的思维把流程、数据都梳理好，你提到的东西才可能被翻译为软件，翻译为数字工具。我们要增强结构化思维，能够说清自己到底要啥，然后把它转变成数字工具，让自己成为一个合格的数字化劳动者。</p><p>还有一点需要提醒，随着技术的发展，从业者的技能也需要随之变化。很多传统企业的人，思想封闭，技能很多年没有变过，这是值得警惕的。</p><h2 id="数字化转型与信息化的区别是什么？是否有核心的技术差距？"><a href="#数字化转型与信息化的区别是什么？是否有核心的技术差距？" class="headerlink" title="数字化转型与信息化的区别是什么？是否有核心的技术差距？"></a>数字化转型与信息化的区别是什么？是否有核心的技术差距？</h2><p>关于这个问题，<code>我的看法就是你要分不清就别分了，只要方向对了就行。因为我们大多数时候是做实践，并不是做理论研究，只要把握住大方向就行。</code>这个方向你看国家政策也好，看互联网行业的实践也好，看这两年行业的趋势也好。我理解数字化就围绕三件事：</p><p>第一，数据到底能不能成为一个新的生产工具？能不能实现数据驱动决策，驱动业务？第二，以数据为第一要素，围绕着数据做工具。第三，通过移动互联网拓展内外部销售渠道。</p><p>你只要沿着这三个方向走，就都是数字化。我常对企业管理者说，你要是能把数据分析明白，把数据对生产经营的作用发挥出来，没有人敢说你不是数字化。</p><p>信息化这个词最早是一位日本学者在上世纪 60 年代提出来的，他还是个人文学者，不是干计算机的。提出来之后西方也比较接受，后来就成了大家公认的信息化了。但他那时候提的信息化比较简单，你可以认为就是计算机的使用率和网络的普及率，这俩就算是衡量信息化的标准。其实还有一条：在计算机和网络的普及下人们行为的合理化。但这一条就比较虚了，不好度量。</p><p>我们常说搞信息化的时候做的软件全是竖井烟囱式开发，相互之间无法连接，业务协作不好，数据也不一致，总有各种数据质量问题。<code>如果从技术延续的角度来看，数字化技术也是信息化技术的延续。数字化相较信息化，最大的差别是全局化的整体设计。</code>数字化就像比尔·盖茨提出的数字神经系统那样，要大家做的系统不再分割，能连上，数据和业务能够贯通。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;对于企业而言，数字化转型早已经是一个绕不开的话题。到底什么是数字化转型？好像很少有人说清楚，今天看到一篇文章，还不错，转给大家看看。&lt;/p&gt;</summary>
    
    
    
    <category term="随想杂谈" scheme="https://jamesyyang.github.io/categories/%E9%9A%8F%E6%83%B3%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="数字化转型" scheme="https://jamesyyang.github.io/tags/%E6%95%B0%E5%AD%97%E5%8C%96%E8%BD%AC%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>如何说清楚软件架构</title>
    <link href="https://jamesyyang.github.io/2023/04/08/cognition-how-communication-architecture/"/>
    <id>https://jamesyyang.github.io/2023/04/08/cognition-how-communication-architecture/</id>
    <published>2023-04-08T05:14:08.000Z</published>
    <updated>2023-04-08T05:44:24.402Z</updated>
    
    <content type="html"><![CDATA[<p>最近参加了几次设计评审，感觉大家对如何说清楚一个系统架构不是很清楚。很多同学上来就讲表结构，或者上来就讲API接口文档。也不知道参会的其他同学是什么感觉，反正我是听得一头雾水。</p><p>那么怎么才能说清楚一个软件架构呢？</p><span id="more"></span><h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><p>我猜很多人肯定会想到画图呀，架构图。没错，关键是怎么画呢？</p><p>在这里，介绍一个<a href="https://c4model.com/">C4模型</a>。</p><p>C4模型是一种用于可视化软件架构的方法，它由Simon Brown提出，旨在帮助软件开发团队描述和沟通软件架构，无论是在前期设计阶段还是在回顾现有代码库时。C4模型的名称来源于它包含的<code>四种抽象层次</code>：Context（上下文）、Container（容器）、Component（组件）和Code（代码）。</p><p><code>Context层</code>描述了软件系统所处的环境和范围，以及与之交互的人员和其他系统。Context层可以用一个系统上下文图来表示，显示出软件系统的名称、边界、职责、用户和外部依赖。</p><p><code>Container层</code>放大了软件系统内部，展示了系统由哪些高级技术构建块组成，例如Web应用程序、移动应用程序、数据库、消息队列等。Container层可以用一个容器图来表示，显示出容器的名称、类型、技术选择、职责和关系。</p><p><code>Component层</code>进一步放大了容器内部，展示了容器由哪些组件组成，以及组件之间是如何协作的。组件可以根据不同的标准进行划分，例如职责、功能、模式或者框架。Component层可以用一个组件图来表示，显示出组件的名称、类型、职责和关系。</p><p><code>Code层</code>最终放大了组件内部，展示了组件是如何实现的。Code层可以用一个代码图来表示，例如UML类图，显示出类的名称、属性、方法和关系。</p><p>每一个层次它都有一种类型的图，具体可以去官网看一下。四个层次的关系大概是这样</p><img src="/images/c4.png" class="" width="800"><h3 id="结构层次"><a href="#结构层次" class="headerlink" title="结构层次"></a>结构层次</h3><p>所以，软件架构属于用来说清楚一个事物的结构的，而C4模型告诉我们，<code>谈结构的时候一定要说清楚在什么样的抽象层次来谈</code>。这非常的重要。</p><p>现实生活中，很常见的说层次结构的图就是<code>地图</code>。而每张地图上面一定会有一个<code>比例尺</code>，比例尺其实就告诉了我们这个地图是在什么样的一个抽象层次上来描述地理位置。</p><p>我们通过地图来查找一个地方的时候，也通常会从一个抽象层次较高的位置开始，逐层展开。这符合人的思维习惯，由高至低，由大到小。</p><p>C4模型其实就是干了这么一个事，只不过它明确了架构图应该有的几个层次是什么，如果大家都follow这么一个规范，那么交流架构会变的比较轻松。</p><h3 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h3><p>我们把这个话题再推进一步，其实要说清楚任何一个事情都是有技巧的。</p><p>如果你是要解释一个解决问题的方案，那么可以遵循：SCQA框架。</p><p>如果你是在讲一个故事，那么可以抓住：时间，地点，人物，情节。</p><p>如果你是在表达一个观点，那么可以围绕：论点，论据，结论。</p><p>…………</p><p>那么再进一步，如果你要说清楚一个事，请抓住它的<code>脉络</code>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近参加了几次设计评审，感觉大家对如何说清楚一个系统架构不是很清楚。很多同学上来就讲表结构，或者上来就讲API接口文档。也不知道参会的其他同学是什么感觉，反正我是听得一头雾水。&lt;/p&gt;
&lt;p&gt;那么怎么才能说清楚一个软件架构呢？&lt;/p&gt;</summary>
    
    
    
    <category term="认知杂说" scheme="https://jamesyyang.github.io/categories/%E8%AE%A4%E7%9F%A5%E6%9D%82%E8%AF%B4/"/>
    
    
    <category term="架构" scheme="https://jamesyyang.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>图说HTTP</title>
    <link href="https://jamesyyang.github.io/2023/03/19/deep-http/"/>
    <id>https://jamesyyang.github.io/2023/03/19/deep-http/</id>
    <published>2023-03-19T00:40:27.000Z</published>
    <updated>2023-03-19T00:43:01.311Z</updated>
    
    <content type="html"><![CDATA[<p>你了解HTTP吗？包括哪些内容呢？</p><span id="more"></span><img src="/images/full-http.png" class="" width="1200">]]></content>
    
    
    <summary type="html">&lt;p&gt;你了解HTTP吗？包括哪些内容呢？&lt;/p&gt;</summary>
    
    
    
    <category term="深入理解" scheme="https://jamesyyang.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    
    
    <category term="HTTP" scheme="https://jamesyyang.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>ChatGPT为什么是现在出来</title>
    <link href="https://jamesyyang.github.io/2023/03/18/thinking-why-chatgpt/"/>
    <id>https://jamesyyang.github.io/2023/03/18/thinking-why-chatgpt/</id>
    <published>2023-03-18T06:04:59.000Z</published>
    <updated>2023-03-18T07:41:00.587Z</updated>
    
    <content type="html"><![CDATA[<p>ChatGPT 4.0来了，所以想继续聊聊这个话题。但是我想换个角度来看这个问题。</p><span id="more"></span><p>ChatGPT的诞生到底是技术发展到这个阶段的必然产物，还是美国故意在这个时候抛出来的概念呢？我认为都是。</p><p>美国从去年开始有经济衰退的苗头，所以接连抛出了元宇宙、ChatGPT两个概念。这是他们解决经济问题的策略，和国内动不动就修路、架桥、盖房子的思路是完全不同的。为什么他们要搞这种虚头八脑的东西，而不搞大基建呢？不是他们不搞，是他们已经过了那个阶段了。</p><p>人类社会经历了漫长的农耕时代，快速经历了工业时代，现在进入共识经济时代。</p><p>农耕时代，财富的定义就是粮食，其他啥也不是。</p><p>进入工业时代，生产力大幅提升，产品可以量产，财富开始迅速累积，人类的物质生活的诉求得到了充分的满足。美国已经走完了工业时代。吃饭有极致的，住房也有极致的，人人都吃成胖子，人人都住别墅，人人都几部车，接下来怎么拉动工业品消费呢？你可以说第三产业也好，你可以说虚拟产品也好，你可以说精神产品也罢，都只能用这些共识消费来拉动需求。</p><p>消费者三年买一次硬件，他可能三天就买一次软件，玩腻了过三天又买新的。所以，面对经济衰退的时候，抛一个元宇宙不行，就继续，再抛一个AI出来。让资本市场愿意继续投入到所谓虚头八脑的行业里。</p><p>什么是共识经济？我特地问了ChatGPT，他说：<code>共识经济是指在数字化时代，人们通过互联网、社交媒体等方式，形成了一种共识，即大家都认为某些事物有价值，从而形成了一种新的经济形态。这种经济形态的特点是，它的价值体系是由大众共同决定的，而不是由少数人或者某个机构决定的。</code></p><p>所以，在共识经济时代里，财富被重新定义了，通过什么重定义？<code>通过大家都觉得，通过共识定义出来的。</code></p><p><strong>共识是什么？集体的想象。</strong> 按照全球的游戏规则，财富总量只增不减，农业品承载不了就只能工业品上，工业品也承载不了了，那只能想象力上。而想象力的本质就是共识。</p><p>说回到国内，中国太大了，去年才完成了脱贫，换句话说，有的地方才刚刚离开农耕时代。而大部分城市可能正处于工业时代，小部分地区已经进入了共识经济时代。</p><p>在这个时代交叉的地带，你会发现事情在发生变化。资本家都纷纷站到了前台，当起了网红。为什么？因为资本在这个时代的话语权已经越来越小，共识的话语权越来越大。<code>谁能得到大家的认可，谁能聚集大家的想象力，谁才能获得财富。</code></p><p>所以，你就能理解网红带货这个现象了。网红本来就自带共识属性，粉丝的多少就决定了他得到的共识有多少。</p><p>零售这个行业可能未来要被改写，商品本身的好坏可能并不是决定性作用，而企业的品牌效应，文化情怀可能会占主导，这直接会决定了消费者对企业本身的认可程度。</p><p>中国人一直是脚踏实地，埋头苦干的形象，这是我们的优势，但是进入共识经济时代，可能这个优势就不在了，我们也需要“<code>抛弃务实，开始务虚</code>”了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;ChatGPT 4.0来了，所以想继续聊聊这个话题。但是我想换个角度来看这个问题。&lt;/p&gt;</summary>
    
    
    
    <category term="随想杂谈" scheme="https://jamesyyang.github.io/categories/%E9%9A%8F%E6%83%B3%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="ChatGPT" scheme="https://jamesyyang.github.io/tags/ChatGPT/"/>
    
  </entry>
  
  <entry>
    <title>怎么看ChatGPT</title>
    <link href="https://jamesyyang.github.io/2023/03/01/thinking-chatgpt/"/>
    <id>https://jamesyyang.github.io/2023/03/01/thinking-chatgpt/</id>
    <published>2023-03-01T05:25:26.000Z</published>
    <updated>2023-03-18T06:03:54.309Z</updated>
    
    <content type="html"><![CDATA[<p>如果要问最近一段时间全网最火的话题是什么？我相信大家一定会说：ChatGPT。</p><span id="more"></span><p>基本上所有的网红和大V都在蹭这个话题的流量，有写科普的，有写技术的等等。</p><p>今天我也免不了这个俗。</p><p>要想利用好一个技术，首先就要了解清楚一个技术。注意，我说的是利用。本质上来说，目前所有的AI技术，都不可能完全替代人类。</p><p>为什么？因为<code>AI不会撒谎</code>。换句话说，AI表达的，就是它要表达的，但人类表达的，远不止于此。</p><p>我常说，中国有句老话：<code>见人说人话，见鬼说鬼话</code>。其实全世界的人讲话也是一样的，他为什么选择这个时间说这个，他为什么不选择这个时间说那个，或者那个时间说这个。又或者这个时间他为什么不说这个，他为什么沉默，又或者他为什么说了那个。</p><p>这些事情，人类是可以理解的，但是AI理解不了。</p><p>几年前阿尔法狗战胜李世石靠什么？靠算法迭代？不，这不是最根本的，最根本的它靠什么？它靠围棋有规则。</p><p><code>围棋是一个明规则的游戏，可人类是一个既有明规则还有潜规则的游戏</code>。</p><p>潜规则往往决定了做什么（What），明规则常常决定了怎么做（how）。所以，如果你在how的领域里和AI比拼，那么迟早是会被超越的。当然，换句话说，当AI能在what的领域有所突破的话，那地球的统治权就要易主了。</p><p>所以现阶段，我们应该充分利用AI在how领域的能力，用它来提升我们的工作效率，充分利用好这个可以不眠不休的小助理。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如果要问最近一段时间全网最火的话题是什么？我相信大家一定会说：ChatGPT。&lt;/p&gt;</summary>
    
    
    
    <category term="随想杂谈" scheme="https://jamesyyang.github.io/categories/%E9%9A%8F%E6%83%B3%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="ChatGPT" scheme="https://jamesyyang.github.io/tags/ChatGPT/"/>
    
  </entry>
  
  <entry>
    <title>目标很好为什么无法落地</title>
    <link href="https://jamesyyang.github.io/2023/02/24/thinking-how-achieve-object/"/>
    <id>https://jamesyyang.github.io/2023/02/24/thinking-how-achieve-object/</id>
    <published>2023-02-24T05:34:27.000Z</published>
    <updated>2023-02-24T06:08:00.980Z</updated>
    
    <content type="html"><![CDATA[<p>上次说到了<a href="/2023/02/16/thinking-why-goals/" title="为什么需要目标">为什么需要目标</a>，今天来说说如何达成目标。</p><span id="more"></span><p>只有目标，但是不知道怎么达成，就会让目标变成空谈，也是我们经常说的<code>执行力太弱</code>。</p><p>今天我想用一个非常简单的类比来解释这个问题，不扯太多大道理。</p><h2 id="导航软件"><a href="#导航软件" class="headerlink" title="导航软件"></a>导航软件</h2><p>导航软件都用过吧，我们今天就用它来思考一下目标应该如何达成。</p><p>使用导航软件，首先要设定一个<code>目的地</code>，类比我们的<code>目标</code>。</p><p>然后，导航软件就告诉你通过什么路径可以到达目的地了。这么神奇？你有深入思考过从目的地到路径这个过程中，发生了什么吗？</p><p>第一，它要先<code>定位</code>你在哪。这样才能计算你和目的地之间的距离。</p><p>第二，它要知道你的<code>偏好</code>，比如你选中的交通工具，自驾还是骑车。还有你的导航优先级，是时间优先还是距离优先。有了它，才能规划路线。</p><p>第三，在导航过程中会随时<code>纠偏</code>，走错路的时候有提示音。</p><p>第四，在关键路径点有<code>更优方案</code>推荐，以便我们根据实际情况进行调整。</p><p>好了，明白了这四点，我们就可以来类比我们如何达到目标了。</p><p>第一，<code>定位</code>你或者你的组织，看看我们和目标之间的差异，然后心中有个数，到底这个目标是很简单还是很困难，如果简单，那么可能是一个短期目标，如果很难，可能是一个长期目标，或者说是一个无效的目标，永远也达不到。</p><p>第二，确定达到目标的<code>偏好</code>，什么叫偏好？就是你愿意<code>为了达到这个目标付出什么</code>。更通俗的说就是计算一下愿意花费的成本，包括钱、时间、人力等等。不同的成本会影响到落地方案的选择。</p><p>第三，执行过程中要随时<code>纠错</code>，也就是需要有人来监督，否则走错了后，返工的成本是非常高的。</p><p>第四，关键节点要<code>复盘</code>，复盘的目的就是看过去一段时间，我们做对了什么，做错了什么，哪些需要改进，便于在下一个阶段有<code>更优方案</code>。</p><p>通过这个对比，是不是很清楚了？其实你做任何事情，都可以用这个步骤来指导你落地你的想法，达到目标。</p><h2 id="OKR"><a href="#OKR" class="headerlink" title="OKR"></a>OKR</h2><p>OKR我<a href="/2021/12/03/thinking-kpi-or-okr/" title="以前说过一次">以前说过一次</a>：它就是目标管理的方法。</p><p>很多同学觉得写O（Object）很容易，但是KR（Key Result）很难。</p><p>其实通过上面的类比就知道，KR就是路径上的关键节点，只要能达到这几个关键节点，那么我们的路径一定就不会偏差太远。</p><h2 id="决策"><a href="#决策" class="headerlink" title="决策"></a>决策</h2><p>顺便再提一下决策。决策就是上面提到的四点中的前两点，也就是根据<code>目标</code>，结合自身的<code>定位</code>以及愿意付出的<code>成本</code>来确定方案。</p><p>更通俗的说：<code>你想要什么？你有什么？你愿意付出什么？</code></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上次说到了&lt;a href=&quot;/2023/02/16/thinking-why-goals/&quot; title=&quot;为什么需要目标&quot;&gt;为什么需要目标&lt;/a&gt;，今天来说说如何达成目标。&lt;/p&gt;</summary>
    
    
    
    <category term="随想杂谈" scheme="https://jamesyyang.github.io/categories/%E9%9A%8F%E6%83%B3%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="目标" scheme="https://jamesyyang.github.io/tags/%E7%9B%AE%E6%A0%87/"/>
    
  </entry>
  
  <entry>
    <title>为什么制定目标</title>
    <link href="https://jamesyyang.github.io/2023/02/16/thinking-why-goals/"/>
    <id>https://jamesyyang.github.io/2023/02/16/thinking-why-goals/</id>
    <published>2023-02-16T04:44:21.000Z</published>
    <updated>2023-02-16T00:11:12.491Z</updated>
    
    <content type="html"><![CDATA[<p>前几天一个正在做绩效的同学问我一个问题：为什么要制定目标？</p><span id="more"></span><p>这是一个有意思的问题，大家平时关注的是如何制定目标，不管是用KPI还是OKR，他们本质都是在做目标管理，但是可能很少有人思考过为什么要制定目标。</p><p>要想彻底回答这个问题，我们可以从一个物理定律开始：<code>熵增定律</code>。</p><blockquote><p>如果物理学只能留一条定律，我会留熵增定律。</p></blockquote><p>说这句话的人叫吴国盛，清华大学的科学史系主任。为什么选这条定律？因为它揭示了宇宙演化的终极规律。</p><p>这个规律包括<code>我们所有生命和非生命的演化规律</code>，生命里又包含着个人和群体的演化规律。</p><ul><li>非生命：比如物质总是向着熵增演化，屋子不收拾会变乱，手机会越来越卡，耳机线会凌乱，热水会慢慢变凉，太阳会不断燃烧衰变……直到宇宙的尽头——热寂。</li><li>生命与个人：比如自律总是比懒散痛苦，放弃总是比坚持轻松，变坏总是比变好容易。只有少部分意志坚定的人能做到自我管理，大多数人都是作息不规律，饮食不规律，学习不规律。</li><li>生命与群体：比如大公司的组织架构会变得臃肿，员工会变得官僚化，整体效率和创新能力也会下降；封闭的国家会被世界淘汰。</li></ul><p>这些所有的现象都可以用一个定律来解释——熵增定律。它的定义：<code>在一个孤立系统里，如果没有外力做功，其总混乱度（熵）会不断增大</code>。</p><p>事物总是向着熵增的方向发展，所以<code>一切符合熵增的，都非常的容易和舒适</code>，比如懒散。</p><p>如果要详细了解熵增定律，大家可以自行搜索一下。</p><p>那么怎么解决呢？其实从它的定律里已经可以看到解法：<code>打破孤立，主动做功</code>。怎么理解？</p><p>其实生命的进化史就是努力对抗熵增的过程：</p><ul><li>生命每天的新陈代谢就是在打破孤立。新陈代谢的过程就是在排除体内的冗余的熵，呼吸和饮食就是在吸收新的可用的物质和能量。</li><li>而生命的进化就是在主动做功，通过适应环境的变化，主动进化出一些新的能力，让自己的生命得以延续。</li></ul><p>好的，回到我们今天的主题，为什么要制定目标呢？相信你可能已经有答案了。</p><p>不管是个人还是团队，通过制定目标实现主动做功，让我们远离舒适区。良好的目标管理可以让组织内部目标得以对齐，从而达到有序。</p><p>同时，通过对目标达成率进行优胜劣汰，可以排除组织内部冗余的熵，从而有能力吸收新的能量。</p><p>说到这里，你也可以马上回顾一下你的目标，设定的合理吗？能有效避免熵增吗？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前几天一个正在做绩效的同学问我一个问题：为什么要制定目标？&lt;/p&gt;</summary>
    
    
    
    <category term="随想杂谈" scheme="https://jamesyyang.github.io/categories/%E9%9A%8F%E6%83%B3%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="目标" scheme="https://jamesyyang.github.io/tags/%E7%9B%AE%E6%A0%87/"/>
    
    <category term="熵增定律" scheme="https://jamesyyang.github.io/tags/%E7%86%B5%E5%A2%9E%E5%AE%9A%E5%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>白话微服务</title>
    <link href="https://jamesyyang.github.io/2023/02/15/deep-micro-service/"/>
    <id>https://jamesyyang.github.io/2023/02/15/deep-micro-service/</id>
    <published>2023-02-15T04:54:04.000Z</published>
    <updated>2023-02-15T08:19:17.617Z</updated>
    
    <content type="html"><![CDATA[<p>整理了以前一些自己对微服务的理解</p><span id="more"></span><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>研究一个东西之前，我喜欢先追本溯源，看清它的本质，然后再来研究，就不会迷失方向。</p><p>所以，我们先从分布式开始研究。</p><h3 id="什么是分布式？"><a href="#什么是分布式？" class="headerlink" title="什么是分布式？"></a>什么是分布式？</h3><p>为什么会出现分布式？</p><ol><li>软件功能越来越复杂，需要分。</li><li>计算资源跟不上，需要分。</li></ol><p>所以，用一个简单的定义来说明分布式：</p><blockquote><p>分布式就是指多进程协作提供一个完整功能。</p></blockquote><p>两个重点：</p><ol><li>多进程：意味着要把原有功能做一个拆分，怎么拆？如何拆？这非常重要。</li><li>协作：意味着各个进程要通信、要管理、要协调，这个就涉及到分布式后面的一系列原理，包括CAP，这个是治理的部分。</li></ol><p>所以，分布式就是一个“分治”的过程。（更多关于分布式的思考请看旧文：<a href="/2022/04/02/deep-distribute/" title="聊聊分布式">聊聊分布式</a>）</p><h3 id="什么是服务化？"><a href="#什么是服务化？" class="headerlink" title="什么是服务化？"></a>什么是服务化？</h3><p>所以，接下来我们来看服务化，了解了分治这个概念，那么就会明白服务化的出现时一个顺理成章的事情。</p><p>服务化就是在讨论怎么拆的问题。回顾一下我们写代码的学到的OOP原则。OOP的世界里充满了对象，如何来组织对象是一个很重要的话题。所以有很多模式，很多原则。</p><p>所以，我们得到一个结论，叫做：<code>高内聚，低耦合</code>。这样的拆分是最高效的，并且复用率应该是最好的。</p><p>同时，满足这个特性的服务应该是接口简单的，职责单一的，大家想想是不是？同时，如果服务的复用率越高，那么整个系统的效率应该也是越高。</p><p>接下来说到正题了。</p><h3 id="什么是微服务？"><a href="#什么是微服务？" class="headerlink" title="什么是微服务？"></a>什么是微服务？</h3><p>首先来说，微服务肯定是服务化的一种延续，一种新的体现形式。并且你其实很难给它一个定义，但是他一定会有一些特征。</p><ul><li>粒度更细——产品思维的转变</li><li>独立部署</li><li>独立维护</li><li>运维复杂</li></ul><p>粒度更细意味着拆得更小，为什么？大家玩过搭积木吧，如果都给你一些体积较大的积木，你能够搭建出来的图形其实是有限的。体积小的积木可塑性更强。</p><p>所以，这说明我们的产品交付时间要求更短，版本更新更快，这也说明我们做产品的思路在发生改变，我们要更靠近用户，更快的响应用户的需要，更多的去试错。</p><p><code>软件开发从最初的瀑布模型，到后来的敏捷，再到现在的DevOps，体现了对迭代速度要求越来越快，我们需要更快的响应用户的需求，这是产品思维最大的转变。</code></p><p>独立部署、独立维护、运维复杂：这是我们刚才提到的分治里的治。为什么到微服务我们才开始提到治？因为分的粒度小了，那么模块数量就会大大上升，怎么去治理它？治理的好坏很大程度上决定了你微服务的成败。所以，如果没有一个好的治理或者说管理平台，那么就不要去实施微服务。</p><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>分布式系统里不得不提一下中间件：<code>为提供通信标准而生</code>。</p><p>从名字上就可以形象的看到，这个就是分布式中夹在各个分开了的模块中的东西。它用来干什么？</p><p>我们刚才就提到了，分布式中各个进程，各个模块间要通信，但是如果大家没有一个通信标准，那就乱套了，中间件的出现就是来提供这么一个标准。</p><p>你只要按照我的标准来，那么就可以顺利的通信。</p><p>所以你会看到有这么一些中间件的出现：RPC通信，数据库访问，消息队列等等。</p><h2 id="分而治之"><a href="#分而治之" class="headerlink" title="分而治之"></a>分而治之</h2><h3 id="分"><a href="#分" class="headerlink" title="分"></a>分</h3><p>再正式说分之前，首先我们必须有一个观念：<code>微服务不是银弹</code>，并不是所有系统都要做成微服务。</p><p>任何产品在雏形期，模型验证期的时候，不需要微服务，甚至不需要分布式，怎么简单怎么来，简单就快，复杂就慢，这个是基本道理。</p><p>反过来说，分布式，服务化，微服务一定是产品进入稳步发展期的产物。那么什么时候开始分呢？</p><ul><li>团队人开始变多</li><li>开发周期开始变长</li><li>发布必加班</li><li>上线必出bug</li></ul><p>这些情况是不是有一种似曾相识的感觉？</p><p>搞不定怎么办？加人。加人还不行？Schedule太短了，多给点时间吧。一到发布就一片混乱，加班、熬夜家常便饭，甚至发版前还要烧香。上线后不是这出问题就是那出问题，频繁打补丁。</p><p>这就说明服务复杂度太高，耦合太紧密，这个时候就要考虑做拆分了，将模块拆分小一点，每个模块的复杂度降低，并且每个服务单独部署，也降低了发布和运维的复杂度。</p><p>当然，复杂度这个其实不太好衡量，我们也可以换一个思路。应该说，当你需要“<code>弹性</code>”的时候，你就需要分，你就需要微服务。</p><p>这里的弹性指两个方面：</p><ul><li>第一，各个模块的性能要求不同，有的模块访问量大，有的模块性能要求低。如果对单体整体扩容，那么资源浪费比较大。</li><li>第二，各个模块的发布周期不同，有的模块需求频繁变动，发布周期较短。如果每次发布都是整个单体的发布，那么发布复杂度太大，容易出错。</li></ul><p>为了应对这两个弹性要求，业界提出了微服务的架构方式。而容器的出现，加速了微服务的普及程度。</p><p>当系统微服务化比较彻底的时候，你可以想象一下容器的数量是很庞大的，如何运维？这个时候K8S就出来了。</p><p>当然，如果没有K8S的出现，也会有K9S，哈哈。因为必须要有这么一个东西出来一统江湖，否则各大公有云厂商就有可能有不同的容器编排方案，那么通用性就不够好。</p><p>那么怎么分呢？</p><p>不管怎么分，我们的原则没有变：高内聚，低耦合。这也是检验我们分的好坏的一个标准。</p><p><code>第一种分法就是纵向分，按照业务维度分，将不同的功能模块服务化，独立部署和运维。</code></p><p>这个很好理解，我们现在MIS的团队基本上是按业务维度来的，比如SO，PO等。只是这个维度很多年不变，这个维度现在是否还是最佳维度，这个就不好评判了，大家可以自行思考。</p><p><code>第二种分法是横向的，按照依赖关系。</code>这个怎么理解？举个例子，比如我们的网站，任何模块都需要显示用户昵称，那么这个用户昵称的模块就可以做成一个微服务。也就是所谓的公共模块。</p><p>具体在实践中如何分，可能没有一个定论，总之一个最高原则就是：<code>高内聚，低耦合，分完后，看看我们的服务是不是达到了这个标准。</code></p><p>在实施过程中可以两种分法综合使用。</p><p>需要注意的是：当你的团队决定要对业务进行微服务架构改造时，要避免一上来就妄想将整个业务进行服务化拆分、追求完美。这种想法是很危险的，一切的技术改造都应当以给业务创造价值为宗旨，所以业务的稳定性要放在第一位，切忌好高骛远。正确的方法是首先从众多业务中找到一个小的业务进行试点，前期的技术方案以满足这个小的业务需求为准，力求先把这个小业务的微服务架构落地实施，从中发现各种问题并予以解决，然后才可以继续考虑更大规模的推广。</p><p><code>另外，要分就要彻底分干净，不要藕断丝连。连数据库也一定要分出去。</code></p><h3 id="治"><a href="#治" class="headerlink" title="治"></a>治</h3><p>先上一个地图：</p><img src="/images/micro-service-1.png" class="" width="500"><p>微服务到底包含些什么东西。</p><ul><li>服务描述：如何对外介绍自己，告诉对方如何调用自己。比如我们常见的Swagger。也有用XML描述自己的，比如以前的web service或者WCF。</li><li>注册中心：有了自我介绍，那么下一步就是告诉别人可以在哪找到自己。通常来说，服务在启动的时候可以主动告诉注册中心，自己上线了。当自己发生变更或者销毁时，也通知注册中心。那么消费者在启动的时候从注册中心订阅服务，就可以开始消费了。注册中心可以想象成一个电话黄页。</li><li>服务框架：不是我们说的Framework哈，Framework是开发类库。框架是定义了如何通信，TCP还是HTTP，数据如何传输？JSON还是Protobuffer？</li><li>服务监控：因为微服务数量多，调用量大，所以需要实时监控服务是否正常。那么一个监控系统包括几个部分：收集所有调用数据，处理数据，数据展示。处理数据主要是说按照一定的指标来汇总，比如按秒来计算访问量，平均响应时间等等。</li><li>服务追踪：除了监控，还需要记录服务调用经过的每一层链路，以便出问题时快速定位故障位置。</li><li>服务治理：治理是一个大头。总的来说，治理就是通过各种手段保证服务的正常运转。包括路由、负载、心跳、限流等等。</li></ul><p>好了，这个图就是微服务的所有组成部分，但是在实施的过程中是有差异的，<code>具体如何落地，需要看我们的部署方式，架构模式，包括：RPC方式，边车（网格）模式，网关模式。</code></p><h2 id="部署模式"><a href="#部署模式" class="headerlink" title="部署模式"></a>部署模式</h2><p>不同的部署，会造成在治理上的方式有所不同。</p><h3 id="边车模式"><a href="#边车模式" class="headerlink" title="边车模式"></a>边车模式</h3><img src="/images/micro-service-2.png" class="" width="500"><p>边车模式就是用来改进传统的RPC的，对于像 “ 监视、日志、限流、熔断、服务注册、协议转换……” 这些功能，其实都是大同小异，甚至是完全可以做成标准化的组件和模块的，所以把它们分离出去，就变成了边车。</p><p>一般来说，我们有两种方式实现边车：</p><ol><li>一种是通过 SDK、Lib 或 Framework 软件包方式，在开发时与真实的应用服务集成起来。</li><li>另一种是通过像 Sidecar 这样的方式，在运维时与真实的应用服务集成起来。</li></ol><p>这两种方式各有优缺点。</p><ol><li>以软件包的方式可以和应用密切集成，有利于资源的利用和应用的性能，但是对应用有侵入，而且受应用的编程语言和技术限制。同时，当软件包升级的时候，需要重新编译并重新发布应用。</li><li>以 Sidecar 的方式，对应用服务没有侵入性，并且不用受到应用服务的语言和技术的限制，而且可以做到控制和逻辑的分开升级和部署。但是，这样一来，增加了每个应用服务的依赖性，也增加了应用的延迟，并且也会大大增加管理、托管、部署的复杂度。</li></ol><p>实现的重点：</p><ul><li>进程通信问题，是用进程间消息？还是远程调用拦截？</li><li>部署问题，最好用docker。</li><li>边车只负责控制，不能写业务逻辑。</li></ul><h3 id="服务网格"><a href="#服务网格" class="headerlink" title="服务网格"></a>服务网格</h3><img src="/images/micro-service-3.png" class="" width="500"><p>边车形成集群就变成了网格。</p><img src="/images/micro-service-4.png" class="" width="500"><p>加上对整个集群的管理控制面板，就成了我们整个的 Service Mesh 架构。</p><p>目前开源界最流行的解决方案就是Istio，我们看它的架构图：</p><img src="/images/micro-service-5.png" class="" width="500"><p>其核心的 Sidecar 被叫做 Envoy（使者），用来协调服务网格中所有服务的出入站流量，并提供服务发现、负载均衡、限流熔断等能力，还可以收集大量与流量相关的性能指标。在 Service Mesh 控制面上，有一个叫 Mixer 的收集器，用来从 Envoy 收集相关的被监控到的流量特征和性能指标。然后，通过 Pilot 的控制器将相关的规则发送到 Envoy 中，让 Envoy 应用新的规则。最后，还有一个为安全设计的 lstio-Auth 身份认证组件，用来做服务间的访问安全控制。</p><p>Service Mesh和Sidecar模式最大的区别就是，在网格中，sidercar是不需要和服务统一打包统一部署的，所以，Service Mesh可以是一个独立的基础设施，就像一个平台一样。甚至，我们可以想象一下，在Service Mesh中，由于Sidecar是独立的，那么其实可以一组服务共用一个Sidercar，而不需要一一对应，对不对？</p><h3 id="网关模式"><a href="#网关模式" class="headerlink" title="网关模式"></a>网关模式</h3><img src="/images/micro-service-6.png" class="" width="500"><p>总的来说，Gateway 是一个服务器，也可以说是进入系统的唯一节点。这跟面向对象设计模式中的 Facade 模式很像。Gateway 封装内部系统的架构，并且提供 API 给各个客户端。它还可能有其他功能，如授权、监控、负载均衡、缓存、熔断、降级、限流、请求分片和管理、静态响应处理，等等，也就是我们说的服务治理。</p><p>在谈 Service Mesh 的时候，个人觉得并不需要为每个服务的实例都配置上一个 Sidecar。因为复杂度很高，其实，一个服务集群配上一个 Sidecar 就可以了，或是一组类似的服务配置上一个 Sidecar。所以，Gateway的数量决定了系统的复杂程度，极端情况就是Gateway会退变为一个Service Mesh。</p><p>当然，由于Gateway变成进入系统的唯一节点，就需要它具有几个特性：</p><ul><li>高性能：gateway不做业务逻辑处理，尽量和后端服务器在同一个内网中。</li><li>高可用：使用devops，快速部署。</li><li>高扩展：要么用DNS轮询，要么Gateway前面还有一个反向代理。</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>大家都清楚三种模式了吗？</p><p>它们的本质都是：<code>逻辑和控制的分离。逻辑由服务来提供，访问控制和治理由代理来完成</code>。</p><p>边车是在当前服务器上，将远程调用的控制以独立进程的方式进行分离。</p><p>当边车太多，需要对边车进行统一管理的时候就变成了服务网格。</p><p>当网格中需要管理的边车过多，我们可以让很多服务共用一个边车，如果系统中最后大家都使用同一个边车时，就会变成网关模式。</p><h2 id="云原生"><a href="#云原生" class="headerlink" title="云原生"></a>云原生</h2><p>最后简单看一下云原生。CNCF云原生计算基金会如此定义云原生：</p><blockquote><p>“云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括容器、服务网格（Service Mesh）、微服务、不可变基础设施和声明式API。这些技术能够构建容错性好、易于管理和便于观察的松耦合系统。结合可靠的自动化手段，云原生技术使工程师能够轻松地对系统作出频繁和可预测的重大变更。”</p></blockquote><p>实际上，我认为，如果用一句话来说清楚云原生就是：<code>如何让微服务更好的落地</code>。</p><p>还记得刚才我们说的<code>弹性</code>吗？所以，与其说云原生架构，不如说是<code>弹性架构</code>更为形象。</p><p>从开发人员开始写代码开始，一直到测试、上线、运维等等，云原生提供了一个整体的思路和解决方案。</p><p>当然，最核心的基础，就是<code>容器，它是一切的基石</code>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;整理了以前一些自己对微服务的理解&lt;/p&gt;</summary>
    
    
    
    <category term="深入理解" scheme="https://jamesyyang.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    
    
    <category term="分布式" scheme="https://jamesyyang.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="微服务" scheme="https://jamesyyang.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>软件研发中的本质</title>
    <link href="https://jamesyyang.github.io/2022/12/12/deep-essence-of-software/"/>
    <id>https://jamesyyang.github.io/2022/12/12/deep-essence-of-software/</id>
    <published>2022-12-12T04:54:04.000Z</published>
    <updated>2023-02-04T00:39:01.842Z</updated>
    
    <content type="html"><![CDATA[<p>什么是优秀的软件设计？什么是敏捷？</p><span id="more"></span><blockquote><p>摘自《程序员修炼之道》</p></blockquote><h2 id="优秀软件设计的本质"><a href="#优秀软件设计的本质" class="headerlink" title="优秀软件设计的本质"></a>优秀软件设计的本质</h2><p>谈起怎样设计软件，世界上到处都是上师和大神，一个个都渴望向世间传授那些来之不易的智慧。有各种缩略词、列表(好像大多是五条)、模式、图表、视频、演讲甚至(互联网上无奇不有)好像还有一个超酷的系列，是用形意舞的形式来讲解得墨忒耳法则。</p><p>真是惭愧，拙著也未能免俗。不过作为补偿，我们会与时俱进地讲解一些东西，它们可是最近才明显被认可使用的。首先是总体概述：</p><p><code>优秀的设计比糟糕的设计更容易变更</code>。</p><p>能适应使用者的就是好的设计。对代码而言，就是要顺应变化。因此要信奉ETC原则(Easier To Change,更容易变更)——就该如此。</p><p>据我们所知，<code>无论是什么设计原则，都是ETC的一个特例</code>。</p><p>为什么解耦很好？因为通过隔离关注焦点，可让每一部分都容易变更——此谓ETC。</p><p>为什么单一职责原则很有用？因为一个需求变化仅体现为某个单一模块上的一个对应变化——此谓ETC。</p><p>为什么命名很重要？因为好的命名可以使代码更容易阅读，而你需要通过阅读来变更代码——此谓ETC。</p><p><code>ETC 是一种价值观念，不是一条规则</code>。</p><p><code>价值观念是帮助你做决定的：我应该做这个，还是做那个</code>？当你在软件领域思考时，ETC是个向导，它能帮助你在不同的路线中选出一条。就像其他一些价值观念一样，你应该让它漂浮在意识思维之下，让它微妙地将你推向正确的方向。</p><p>那么怎样才能做到？我们的经验是，一开始需要一点有意识的强化。你可能需要花一个星期左右的时间来有意识地问自己：“我刚刚做的事情是让整个系统更容易改变还是更难改变？”当你保存文件时问一遍，当你写测试时问一遍，当你修复Bug时也问一遍。</p><p>ETC里有一个隐含的前提。多条路线中的哪一条更易于将来的变更，ETC假定我们有能力辨别。很多时候，常识通常就不会错，你完全可以据此推断。</p><p>然而有时你找不到线索。这也没关系。这种情况下，我们觉得你可以做两件事。</p><p>第一件事，假设不确定什么形式的改变会发生，你也总是可以回到终极的“容易变更”的道路上：试着让你写的东西可替换。这样，无论未来发生什么，这块代码都不会成为路障。这似乎有点极端，但不管怎样，实际上你一直应该这样做。做起来并不难，想着一直保持代码的解耦和内聚就够了。</p><p>第二件事，把它当作培养直觉的一种方式。在工程日志中记下你面临的处境：你有哪些选择，以及关于改变的一些猜熟，在源码中留个标签，以便之后必须修改这块代码时，进行回顾并给自己留下反锁记录，下一次在行进的通路上再碰到类似的分盆口时，这会有所帮助。</p><h2 id="敏捷的本质"><a href="#敏捷的本质" class="headerlink" title="敏捷的本质"></a>敏捷的本质</h2><p><code>敏捷是一个形容词：它指向你做事情的方式</code>。你可以成为一名敏捷的开发人员。你可以加入一个采用敏捷实践的团队，一个对变化和挫折做出敏捷反应的团队。敏捷指你的风格，并不指你这个人。</p><p><code>敏捷不是一个名词；敏捷有关你如何做事</code>。</p><p>在我们写这篇文章的时候，敏捷软件开发宣言已经诞生将近20年了，我们看到敏捷的价值在许多开发人员身上成功体现，也看到很多优秀团队在获取和利用这一价值上颇有心得，包括指导所做的事情，以及指导如何对所做的事情加以改变。</p><p>然而，我们也看到了敏捷的另一面——很多团队和公司渴望现成的解决方案：让敏捷开箱即用。他们想要的这个东西，也正是许多咨询公司和咨询师很乐意推销的。结果这些公司采用了更多层的管理、更正式的报告、更专业的开发人员和更花哨的岗位头衔，这类头衔的背后其实就是一些“拿着笔记板和秒表的人”。</p><p>我们觉得很多人已经忽视了敏捷的真正含义，因而希望看到人们回归到最基本的东西。</p><p>记住宣言中的价值观：</p><p>我们一直在实践中探寻更好的软件开发方法，身体力行的同时也帮助他人。由此我们建立了如下价值观：</p><ul><li>个体和互动高于流程和工具</li><li>工作的软件高于详尽的文档</li><li>客户合作高于合同谈判</li><li>响应变化高于遵循计划</li></ul><p>也就是说，尽管右项有其价值，我们更重视左项的价值。</p><p>如果有人向你兜售一些东西，而这些东西让你觉得右边的事情比左边的事情更重要，那么这样的人，对于我们和其他宣言作者重视的东西，显然不会认同。</p><p>任何向你推销“开箱即用方案”的人都没有读过这份介绍性声明。这些价值观，是由不断发现更好软件生产方法的行为，所激发和显露出来的。这不是一份静态的文档，它是对生产过程的建议。</p><p><code>永远不可能有一个叫敏捷的工艺流程</code>。</p><p>事实上，无论什么时候有人说，“这么干，你就敏捷了”，显然都是错的。</p><p>因为无论是物理世界中的敏捷，还是软件开发中的敏捷，谈的都是<code>对变化的响应</code>，对开始后所遇到的未知事情做出的响应。奔跑中的羚羊不会沿直线前进，体操运动员一秒钟要纠正数百个错误，因为他们要对环境的变化和脚部位置的微小偏差做出反应。无论是对团队还是对个人开发者，都是如此。在开发软件时，并没有单一的计划可以遵循。在敏捷宣言的四条价值观中，有三条谈的都是这一点，都是关于收集和回应反馈的。</p><p>这些价值观不会告诉你该做什么。当你自己决定要做点什么的时候，它们会告诉你要去追寻什么。</p><p>这些决策总是与环境相关：它们取决于你是谁、团队的性质、你的应用程序、你用的工具、你的公司、你的客户以及外部世界；有很多因素，有重要的也有不重要的。任何固定的、静态的计划，都无法经受这种不确定性。</p><p>那么我们应该做什么？</p><p>没有人能告诉你该做什么。而我们打算告诉你的，是做事时该有的精神。<code>它完全可以归结为如何处理不确定性</code>。敏捷宣言建议你通过收集反馈并采取行动来做到这一点。所以下面是我们以敏捷方式工作的秘诀：</p><ol><li>弄清楚你在哪里。</li><li>朝想去的方向迈出有意义的最小一步。</li><li>评估在哪里终结，把弄坏的东西修好。</li></ol><p>重复这些步骤，直到完成。在每一件事的每个层面上递归地使用这些步骤。有时候，当你收集反馈时，即使是最不起眼的决定也会变得重要起来。</p><p>现在我的代码需要获得账户所有者。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = <span class="title function_">accountOwner</span>(accountID);</span><br></pre></td></tr></table></figure><p>嗯……user是个没意义的名字，应该换成owner。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> owner = <span class="title function_">accountowner</span>(accountID);</span><br></pre></td></tr></table></figure><p>但现在它显得有些累赘。我到底想做什么？在这个情景下，我是要给这个人发一封电子邮件，所以需要找到他们的电子邮件地址。也许我根本不需要账户所有者的全部信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> email = <span class="title function_">emailOfAccountOwner</span>(accountID);</span><br></pre></td></tr></table></figure><p>通过在非常底层的层面上(对变量的命名)应用反馈循环，我们实际上改进了整个系统的设计，减少了这部分代码与处理账户的代码之间的耦合。</p><p>反馈循环也适用于项目的最高层级。我们最成功的一些工作成果，是在开始处理客户需求时偶然产生的。当我们迈出一小步时，就意识到将要做的事情并不是必须要做的，最好的解决方案甚至不涉及软件。</p><p>此循环不仅仅能用于单个项目。团队应该应用它来回顾流程及其起到的效果，不持续对流程做实验的团队，不是敏捷团队。</p><p><code>还可以用来驱动设计</code>。</p><p>在上一章节中，我们曾断言，设计的衡量标准是对设计出的结果进行变更的容易程度：优秀的设计比糟糕的设计更容易变更。</p><p>关于敏捷的讨论解释了为什么会这样。</p><p>你做出了一个改变，后来发现自己并不喜欢。根据清单上的第三步，我们必须能够修复我们破坏了的东西。为了使反馈循环更有效，修复必须尽可能地简单。如果不够简单，我们就只会耸耸肩，而不去修它。为了使整个工作敏捷起来，需要实践优秀的设计，因为优秀的设计使事情容易改变。如果它很容易改变，就可以在每个层面做调整，不会有任何犹豫。</p><p>这就是敏捷。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;什么是优秀的软件设计？什么是敏捷？&lt;/p&gt;</summary>
    
    
    
    <category term="深入理解" scheme="https://jamesyyang.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    
    
    <category term="本质" scheme="https://jamesyyang.github.io/tags/%E6%9C%AC%E8%B4%A8/"/>
    
  </entry>
  
  <entry>
    <title>打坐科学吗？</title>
    <link href="https://jamesyyang.github.io/2022/12/09/cognition-meditation/"/>
    <id>https://jamesyyang.github.io/2022/12/09/cognition-meditation/</id>
    <published>2022-12-09T04:54:04.000Z</published>
    <updated>2023-01-28T07:11:53.875Z</updated>
    
    <content type="html"><![CDATA[<p>打坐，也叫静坐，类似的还有冥想。这个东西到底科学吗？</p><span id="more"></span><p>我之前写过一个文章（<a href="/2018/12/13/immortal-quietly/" title="求静">求静</a>），从“修仙”的角色谈过这个问题，今天我们从另外一个角度谈一下。</p><p>从前面几篇文章中，我们讨论大脑的工作模式，想必你应该比较熟悉了。</p><p>那么，不知道你想过没有，大脑在不思考的时候，会干什么呢？会休息吗？</p><p>答案是不会，这个问题应该很容易理解，如果大脑要休息，你就不会做梦了。你睡着了后，其实一直在做梦，只不过你只记得睡醒前最后一个而已。</p><p>所以，从目前的科学来说，大脑会处于两种状态模式中，我们姑且称为<code>思考模式和后台模式</code>。</p><p>思考模式比较好理解，就是我们专注于某个任务的时候，大脑全部用来思考当前的问题，这个状态下很容易进入所谓的心流状态。</p><p>而什么也不干的时候，大脑就开始自我控制了，干什么呢？用一个计算机术语来说就是：磁盘碎片整理。所以，你可能在走神的时候，忽然产生很多念头，想起很多的人，曾经去过的地方等等。</p><p>在了解了这两个模式以后，我们就会发现，后台模式其实有利有弊。有利是碎片整理可以帮助我们梳理一些想法，把很多东西关联起来，有可能会带来一些灵感和创造性。不好的一面是可能带来负面情绪，因为当你回忆起过去的时候，可能当时的情绪也会涌上心头，而之前我们说过，大脑是非常喜欢“加戏”的，所以，带来的负面情绪会比较多。同时，后台模式太过活跃，自己也会感到比较心烦意乱。</p><p>所以，整体来看，后台模式需要一定的抑制，那么前提就是我们能够尽量的控制我们的大脑。怎么做呢？就是打坐（为了便于叙述，这里打坐就包括了静坐，冥想，正念呼吸等等，其实都差不多）</p><p>打坐是干什么？用佛的说法叫做<code>止观，先止后观</code>。止是什么意思？就是停止你的念头。怎么停止？先切断你的感官系统，包括找一个安静的地方，然后调暗灯光，闭上眼睛，不要喝水，不要吃东西等等。</p><p>做足这些也还不行，只是切断了外部干扰。我们知道，大脑是不可能停止工作的。所以，要先“<strong>心系一缘</strong>”。先把注意力集中到一点上，你坐在那里，唯一还活动的就是呼吸了，所以，我们可以把注意力集中在呼吸上面。并且逐步降低呼吸的频率，拉长每次呼吸的时间。</p><p>这样下来，其实还是不能让大脑停下活动，然后我们就要开始“观”了。观什么？当念头来的时候，你别去理它，而是假装自己是一个旁观者，只是在一旁看看就行，但是不要跟着这个念头走下去。这个时候你会发现念头一个接一个的来，但是你只是旁观而已。慢慢的，它来的就越来越少了。甚至后面念头不来了，这个时候就进入新的阶段了，具体什么可以到时候交流一下。</p><p>这个就是打坐的过程，其实也没什么神秘的，但是贵在坚持，每天坐15分钟，长期坚持下去，你会发现你对大脑的掌控会更好了，思绪更清晰，记忆力会变好了。</p><p>所以，打坐这个过程，不一定为了修仙，其实从目前科学的角度来看，就是让你能够更好的掌控你的大脑而已。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;打坐，也叫静坐，类似的还有冥想。这个东西到底科学吗？&lt;/p&gt;</summary>
    
    
    
    <category term="认知杂说" scheme="https://jamesyyang.github.io/categories/%E8%AE%A4%E7%9F%A5%E6%9D%82%E8%AF%B4/"/>
    
    
    <category term="大脑" scheme="https://jamesyyang.github.io/tags/%E5%A4%A7%E8%84%91/"/>
    
  </entry>
  
  <entry>
    <title>如何应对焦虑</title>
    <link href="https://jamesyyang.github.io/2022/12/08/cognition-anxiety/"/>
    <id>https://jamesyyang.github.io/2022/12/08/cognition-anxiety/</id>
    <published>2022-12-08T04:54:04.000Z</published>
    <updated>2023-01-28T07:08:14.159Z</updated>
    
    <content type="html"><![CDATA[<p>焦虑是情绪的一种，自古就有，为啥现在会被更多的关注呢？</p><span id="more"></span><p>通过<a href="/2022/12/05/cognition-how-brain-works/" title="上一篇">上一篇</a>文章，我们知道了大脑的工作模式。我们应对大部分的日常生活和工作基本上都是通过大脑的心智模型。</p><p>当然，我们做出任何行为，<code>其实对这个行为的结果都是有一个预测的</code>。比如你说了一句话，对方会有什么反应，其实你心里是有一个预期的；再比如你写完一行代码，这个代码会执行出什么结果，你也是有预判的。</p><p>如果结果符合预期，你应该是比较平静的，自然而然嘛。但是，<code>如果结果不符合预期，这个时候你就会产生情绪了</code>。如果结果非常好，那么多半你会高兴；如果结果非常差，多半你会恼怒，恐惧等等。</p><p>情绪的产生其实是提醒大脑，是不是模型出了问题？要不要根据最新的结果调整模型？</p><p>所以，情绪是非常有用的，它是一个报警，提醒我们该做一些自我修复了。</p><h3 id="那焦虑是什么呢？"><a href="#那焦虑是什么呢？" class="headerlink" title="那焦虑是什么呢？"></a>那焦虑是什么呢？</h3><p>当你做出一个行为后，<code>你不知道结果是什么，有可能好，有可能不好，这个时候就是焦虑</code>。</p><p>这一点估计很多同学都有经验，比如你去体检后，等报告的几天是不是就会有点焦虑？真正报告出来了，不管是好还是不好，你就不会焦虑了，即使是不好的结果，但是确定了是什么问题，后面继续治疗即可。</p><p>那么为什么焦虑最近会被那么多人关注呢？<code>因为我们的大脑会“加戏”</code>。结果有可能好，也有可能不好，估计是现代人看太多电视剧的关系，我们往往就会开始想象极端情况，并且自己导演这个剧情的发生，最后一发不可收拾。</p><p>其实，根据一个科学统计，我们担心的事情里面，<code>85%的事情都不会发生</code>。</p><h3 id="那如何应对焦虑呢？"><a href="#那如何应对焦虑呢？" class="headerlink" title="那如何应对焦虑呢？"></a>那如何应对焦虑呢？</h3><p>长期来看，我们应该尽量完善大脑的模型，尽量让自己不处于不知道结果好坏的境地。</p><p>短期来看，当焦虑产生后，自己对自己说一句：好了，我知道了，退下吧。不要“加戏”，因为加戏的部分基本不会发生。</p><p>还可以找个人聊聊，旁观者清嘛，可以很快帮你识别你的加戏部分。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;焦虑是情绪的一种，自古就有，为啥现在会被更多的关注呢？&lt;/p&gt;</summary>
    
    
    
    <category term="认知杂说" scheme="https://jamesyyang.github.io/categories/%E8%AE%A4%E7%9F%A5%E6%9D%82%E8%AF%B4/"/>
    
    
    <category term="大脑" scheme="https://jamesyyang.github.io/tags/%E5%A4%A7%E8%84%91/"/>
    
  </entry>
  
  <entry>
    <title>大脑的工作模式</title>
    <link href="https://jamesyyang.github.io/2022/12/05/cognition-how-brain-works/"/>
    <id>https://jamesyyang.github.io/2022/12/05/cognition-how-brain-works/</id>
    <published>2022-12-05T04:54:04.000Z</published>
    <updated>2023-01-28T07:02:36.057Z</updated>
    
    <content type="html"><![CDATA[<p>我们在<a href="/2020/05/19/cognition-what-is/" title="什么是认知">什么是认知</a>开篇就说过，认知实际就是当你获取到一个信息后，给出什么响应。</p><p>那么是什么在控制这个响应呢？答案就是<code>你的大脑</code>。</p><span id="more"></span><p>今天我们就深入来聊一下这个话题。</p><p>我们的眼睛可以看到五彩斑斓的世界，耳朵可以听到家人与朋友的声音，双手可以跟世界产生各种各样的交互。但其实严格来说，这个说法不准确。看的能力不是眼睛，其实是大脑，眼睛是用看的工具。听也类似。</p><p>大脑其实只是孤零零地悬浮在一片黑暗之中，环绕着它的只有来自860亿个神经元此起彼伏的电信号。大脑就是依靠这些电信号，理解着周围世界的一切。它就像一颗星星，孤独地悬在无垠的幽暗宇宙之中，陪伴着它的只有其他无数颗星星所带来的引力。在这种情况下，大脑每一天的工作是通过外界输入的电信号，微调神经元之间的连接，优化由神经元构成的神经网络，使得这个神经网络能够更好地反映外部世界。</p><p>如何调整呢？首先，大脑会通过调节神经元之间的连接，把外部的环境信息尽可能储存起来。比如：大脑发现一个刺激总是反复出现，就会把对应的神经元节点优先级调高；发现两个信息总是经常被联系起来，就在它们之间创建一条更短的通路；等等。通过这些方式，神经网络能够更快速地对外界刺激做出反应。这个不断优化、调整的神经网络模型，就是我们的心智模型，也是在大脑看来，我们所处的世界所“应该有的样子”。</p><p>然后，当我们接触到新信息时，大脑会根据已有的心智模型对未来进行推断，“预测”我们可能会遭遇什么，需要做出什么反应，可能会引发什么后果。大脑会根据这些结果，产生一个自上而下的预测信号，再把这个预测信号跟自下而上获取到的信息进行综合对比。如果一切吻合，就按照预测的方式行动；如果不吻合，就会产生一个预测误差，这时，大脑或是调整心智模型，或是驱动我们去做出其他行动，来修正和消除这个误差。</p><p>这就是预测加工理论。它可以分成两部分：<code>第一部分是通过每一天、每一分、每一秒的信息输入，不断微调大脑内部的心智模型，以便更好地符合和反映外部世界；第二部分是通过这个心智世界，对我们每天会遭遇到的情况、做出的反应和结果进行预测，通过预测和对比来检验心智模型的有效性</code>。</p><p>用一个简单的例子来类比：你第一天上学，进入教室，老师让大家起立问好，于是你学习到一条规则：上课前要起立问好。大脑会把这条规则写入心智模型里面，试图用它去解释和理解这个世界。接着，第一节课下课，进入第二节课，按照刚刚创建的新规则，你起立问好，其他人也同样做，也得到了老师的认可，这就是一个“符合预测”的情况。于是，这条规则得到了强化，大脑会更加相信它，利用它去处理对应的情境。</p><p>反过来，如果你起立问好，却发现其他人都没有动，那么，大脑就会立刻发出警报：是不是遭遇到一个“不符合预测”的情况了？这时，你的思维就会立刻飞速运转：为什么这条规则失效了？现在的场景跟先前的场景有什么区别？这条规则生效的条件是什么？我是不是需要修改这条规则，使它更加适应更多的不同场景？这就是对心智模型的调整和修补。经过思考和外界的反馈，你就会得到一条更新的规则，再把它写入心智模型中。于是，你的心智模型就会变得更加完善，能够适应更多的情境。</p><p>以上就是大脑本质的工作模式：<code>通过这两部分所构成的回路，不断地让自己更加理解外部世界，更加适应外部世界</code>。</p><p>读到这里你可能就要说了，<code>这不就是机器学习的玩法吗？是的，没错</code>。大脑就是这么工作的。日常生活中，针对大部分的输入，其实大脑都是用现有模型去应付的，比如你吃饭的时候，从来没有思考过要怎么拿筷子，食物放嘴里要怎么嚼烂吧？用个词来说就叫：下意识。</p><p>那么，回到认知这个话题，<code>你的认知能力的高低，也就取决于你的大脑已经训练出来的模型是什么样子，是不是最接近于外部世界真实的样子</code>。</p><p>所以，佛说：一切有为法，如梦幻泡影，如露亦如电。其实没有错，你感受到的外部世界确实不是真实的，而是你的模型反应的样子。</p><p>那么，也正是由于这样的工作模式，会让我们的大脑具备一些特征，接下来我们就来聊一聊。</p><p>既然大脑在每时每刻训练我们的心智模型，所以，大脑对任何接受的信息，都会优先使用心智模型去进行响应。为啥？因为高效啊。只有当你接受到一个模型无法处理的信息时，大脑才会启动思考的过程。</p><p>其实，这是合理的，你想，要是日常生活中每一件事你都需要思考以后才能做出响应，那一天可能也干不了几件事了。</p><p>另外，我们经常说的一句话：<code>熟能生巧。什么叫生巧？也就是说对于这件事，大脑的心智模型已经能够处理了，不需要思考了</code>。这里要特别指出一个陷阱。在当今我们获取信息的各种渠道，各种APP其实是有推荐算法加持的，是很片面的，所以大脑的模型会更容易得到强化，这会让我们的模型变得比较狭隘和偏激。</p><p>那么，随着我们年龄的增加，我们的模型能够处理的信息会越来越多，如果你的生活缺乏变化，那么其实整天都不需要做太多思考。</p><p>当然，这也有不好的地方，有一个词叫：老顽固，也就是指这种情况。所以，大脑在模型逐渐完善后，会更倾向于稳定，尽量少的去改变。这也是合理的，人类还是更喜欢确定性的生活，确定性能够带来安全感。试想一下，要是某天早上起床，突然发现你不在自己家里，周围也都是你不认识的人，你是不是会非常的恐惧？</p><p>所以，根据上面说到的大脑工作的特征，我们要如何在日常中优化我们的心智模型呢？</p><p>你要是了解机器学习，你就应该知道，模型如何全靠你用什么来训练。所以，针对我们的大脑，<code>我们应该喂给它更全面的信息，让它具备一定的广度，同时针对你从事的工作，应该喂一些有难度的知识，让大脑经常的启动思考过程，不至于变得太懒</code>。</p><p>当然，这个难度要适中，避免大脑产生恐惧的负面情绪。最新的科学证明，15%的新知识会是一个效果最好的比例。</p><p>最后总结一下，保持大脑的活力，你得走出舒适圈进行刻意训练，但是也别用力过猛，每天尝试一点变化，量变最终会质变。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们在&lt;a href=&quot;/2020/05/19/cognition-what-is/&quot; title=&quot;什么是认知&quot;&gt;什么是认知&lt;/a&gt;开篇就说过，认知实际就是当你获取到一个信息后，给出什么响应。&lt;/p&gt;
&lt;p&gt;那么是什么在控制这个响应呢？答案就是&lt;code&gt;你的大脑&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="认知杂说" scheme="https://jamesyyang.github.io/categories/%E8%AE%A4%E7%9F%A5%E6%9D%82%E8%AF%B4/"/>
    
    
    <category term="大脑" scheme="https://jamesyyang.github.io/tags/%E5%A4%A7%E8%84%91/"/>
    
  </entry>
  
  <entry>
    <title>作为学生</title>
    <link href="https://jamesyyang.github.io/2022/06/18/education-student/"/>
    <id>https://jamesyyang.github.io/2022/06/18/education-student/</id>
    <published>2022-06-18T04:54:04.000Z</published>
    <updated>2023-02-03T07:58:14.641Z</updated>
    
    <content type="html"><![CDATA[<p>俗话说：活到老学到老。</p><p>所以，学生是我们一辈子都要扮演的角色。</p><span id="more"></span><p>那么，你有想过一个问题吗：<code>学习究竟是什么</code>？</p><p>有一个很类似的过程就是吃饭。食物吃下后，经过消化系统的运化，最终转变成了提供给身体运转的能量。</p><p>学习也是同样的道理，我们吸收到了知识后，最终需要“消化”成我们自己能使用的智慧和本领。这个过程里，最重要的就是消化。</p><p>我们都经历过学生生涯，为什么有的人学的很轻松，有的人学的很累？差异就是有没有这个消化的过程。</p><p>所谓消化知识就是要让新知识和自身的知识体系连接到一起，融入到自己的知识体系中，从而也逐步扩大自己的知识体系。</p><p>那么，要<code>如何才能更好的消化知识呢</code>？</p><p>还是回到吃饭的问题上，同样可以提一个问题：如何吃才能更好的吸收呢？</p><p>答案是适合自己的身体的食物。哈哈，这绝对没有乱说，实际情况就是这样的。</p><p>首先食物不能太素，太素没营养，也不能太荤，太荤的话对消化系统负担太重。所以要适中。但是这个适中是因人而异的，本身体质好的人，可能每天吃几个鸡腿也没什么问题，而体质弱的人，可能就无法消化了。</p><p>同理，知识也一样。你学习的知识不能太简单，太简单没有什么新意，都是自己会的。也不能完全是自己没接触的，这个估计会让自己产生抵触心里，想象一下让一个小学生去学微积分会是什么情况？</p><p>所以，要适中。你学习的知识里应该大部分是自己会的，小部分是新的，这样是最容易调度起自己的积极性的。<code>据说有一个科学研究表明：85% 会的，15% 新的是最佳搭配</code>。</p><p>好了，最合适的知识来了后，<code>如何让它和自己的知识体系融合在一起呢</code>？</p><p>食物吃下肚以后会怎么样？消化系统就要开始工作了，不停的蠕动，反复蹂躏它们，把食物打碎成最容易吸收样子。</p><p>知识也一样，学到新的知识后，需要一个<code>反复实践和验证的过程</code>。用一个我经常给我小孩说的词来描述就是：<code>熟能生巧</code>。</p><p>熟代表了你反复的练习，巧代表了最终融入自己的知识体系。</p><p>不是有一个一万小时理论么？当然，我觉得反复练习是必须的，但是不是绝对的，练习需要有针对性，同时练习中需要根据实际的反馈做调整。用现在流行的话说就是要时刻注意复盘，为下一次练习做优化。</p><p>基本上，有了这个过程后，知识就能变成自己的了。那么，当你的知识体系不断扩张的以后，如何驾驭它们？或者说如何更好的使用它们，发挥更大的效能呢？</p><p>答案是连接。</p><p><code>交易是人和人的连接，创新是知识和知识的连接</code>。</p><p>让自己的知识体系内各个触点产生连接，发生碰撞，激发创新。那么，你拥有的就不是一个体系了，可能是一个有机的生态。</p><p>所以，你会发现，历史上有名的人，大部分都是通才，很少是专才，因为通才的广度更大，产生连接的可能更多。</p><p>好了，最后，想说一下如何提升自己的学习能力。就像前面我提到的，如果你体质太弱，一个鸡腿可能你都无法消化。</p><p>同样的道理，如果你学习能力不行，那么你每次可以吸收的知识是非常有限的。</p><p><code>学习能力一句话概括就是：能调研、能学习、能表达</code>。</p><p>能调研：具备批判性思维方式，是一个能够独立思考的人，不盲从。</p><p>能学习：知道如何掌握一门知识，能够迅速解决问题。</p><p>能表达：具备良好沟通能力，能够与各种人打交道。</p><p>这三点是任何行业任何职业都需要的技艺，并且从目前的社会发展来看，越来越需要这样的技能。因为社会越来越需要的是跨界综合人才，而不是某一领域的专才。</p><p>作为学生是一辈子的事情，并且大部分时间其实你都是一个人在自学，学校的时光其实不太能学到什么知识，我之前说过，学生生涯可能更多的是培养良好的学习习惯而已，真正的学习可能还是在你离开学校以后的时间。</p><p>希望这篇文章能给独自学习的你一些帮助。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;俗话说：活到老学到老。&lt;/p&gt;
&lt;p&gt;所以，学生是我们一辈子都要扮演的角色。&lt;/p&gt;</summary>
    
    
    
    <category term="漫谈教育" scheme="https://jamesyyang.github.io/categories/%E6%BC%AB%E8%B0%88%E6%95%99%E8%82%B2/"/>
    
    
  </entry>
  
  <entry>
    <title>企业文化</title>
    <link href="https://jamesyyang.github.io/2022/04/20/thinking-culture/"/>
    <id>https://jamesyyang.github.io/2022/04/20/thinking-culture/</id>
    <published>2022-04-20T04:44:21.000Z</published>
    <updated>2023-01-28T05:06:16.445Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是文化？"><a href="#什么是文化？" class="headerlink" title="什么是文化？"></a>什么是文化？</h3><span id="more"></span><p>说的简单一点，<code>就是在一个组织内做什么事情，会被大家认可、鼓励</code>。这就是文化。</p><p>文化没有对错，文化的最大价值就是辅助组织达到目标。</p><p>杰克.韦尔奇说过一句话：”<code>如果你不能时常传达你的目标，不能通过奖励巩固你的目标，那么，你的愿景还不如打印愿景的纸有价值。</code>“</p><p>所以，文化就是巩固目标的。</p><h3 id="企业文化四象限"><a href="#企业文化四象限" class="headerlink" title="企业文化四象限"></a>企业文化四象限</h3><p>目前最权威的企业文化分类, 是The Reengineering Alternative中提出的模型。在这个模型中, 作者从多种企业属性中抽取了最关键的两个维度作为企业文化的核心因素: 企业的关注点, 以及企业的决策方式。</p><img src="/images/thinking-2.png" class="" width="700"><ul><li>Control: 控制型文化。典型代表是军队：强调等级、汇报线、 关注现实, 理性的决策。</li><li>Collaboration: 合作型文化。典型代表是球队：强调集体智慧, 关注现实、人性化的决策（协作、创新）。</li><li>Cultivation: 培育型文化。典型代表是宗教：强调意义, 关注可能性, 人性化决策（培养机制）。</li><li>Competence: 能力型文化。典型代表是大学： 强调能力, 关注可能性, 理性决策（胜任力模型）。</li></ul><p>大部分公司都是Control + Competence类型，因为树形组织架构本身就是为了实现自上而下的控制，而基于KPI的考核，就是在强调不同的能力等级。</p><p>工程师文化是Cultivation + Competence，因为工程师文化还需要强调能力的传承。</p><p>志愿者或者非盈利型组织是Collaboration，更多的通过协作来达到目标，强调集体智慧。</p><h3 id="产品文化"><a href="#产品文化" class="headerlink" title="产品文化"></a>产品文化</h3><p>同理可得，产品的文化就是辅助组织研发出符合预期的产品。那如何判断一个组织有没有产品文化呢？</p><ul><li>第一，有没有产品愿景和产品战略？</li><li>第二，有没有快速试错（迭代）的制度？这个迭代不是指开发，而是从需求，设计，实现，上线，验证的全过程迭代。</li><li>第三，技术团队有没有快速落地的能力？</li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;什么是文化？&quot;&gt;&lt;a href=&quot;#什么是文化？&quot; class=&quot;headerlink&quot; title=&quot;什么是文化？&quot;&gt;&lt;/a&gt;什么是文化？&lt;/h3&gt;</summary>
    
    
    
    <category term="随想杂谈" scheme="https://jamesyyang.github.io/categories/%E9%9A%8F%E6%83%B3%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="本质" scheme="https://jamesyyang.github.io/tags/%E6%9C%AC%E8%B4%A8/"/>
    
    <category term="文化" scheme="https://jamesyyang.github.io/tags/%E6%96%87%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>聊聊分布式</title>
    <link href="https://jamesyyang.github.io/2022/04/02/deep-distribute/"/>
    <id>https://jamesyyang.github.io/2022/04/02/deep-distribute/</id>
    <published>2022-04-02T04:54:04.000Z</published>
    <updated>2023-05-04T03:30:44.702Z</updated>
    
    <content type="html"><![CDATA[<p>上次团队内部分享，Skyler同学分享了Raft算法，分享过程中，大家还激烈讨论了一下。说明大家其实对分布式系统的原理和实现还是比较感兴趣的。</p><p>当然，我们不是搞科研的，平时工作中可能用不到这些高大上的知识。不过，如果我们能对这些原理性的东西有一个正确的理解，至少能在平时工作中做技术选型时有一个正确的选择。</p><p>所以，今天我想尝试给大家梳理一下分布式系统中涉及到的一些概念和原理，不会太深入，就算给大家做一个提纲挈领的资料吧，希望你看过后能对分布式系统有一个整体的了解吧。</p><span id="more"></span><h3 id="分布式解决什么问题"><a href="#分布式解决什么问题" class="headerlink" title="分布式解决什么问题"></a>分布式解决什么问题</h3><p>在讨论任何技术之前，我都习惯问一个问题，<code>这个技术要解决什么问题</code>？那么，分布式系统要解决什么问题呢？</p><p>当然，这个问题的答案并不复杂，你可以简单回答：<code>解决单台撑不住的问题</code>。</p><p>深入来看，那什么叫撑不住呢？可能从三个维度来解释吧：<code>可靠性、可扩展性和可维护性</code>。</p><p><strong>可靠性</strong>意味着即使发生故障，系统也可以正常工作。单台的话，如果挂了，那肯定就不可用了，所以也叫单点问题。</p><p><strong>可扩展性</strong>是指负载增加时，系统性能还能够保持在一个有效的范围。如果是单台，那就只能做垂直扩展，例如增加CPU和内存等等。不过这种扩展方式是非常昂贵和容易达到系统极限的。</p><p><strong>可维护性</strong>则意味着许多方面，但究其本质是为了让工程和运营团队更为轻松。单台的话，一旦有系统维护，或者发版之类的，系统就不可用了。</p><p>所以，分布式主要就是解决这些问题的，于是我们把原本一个程序做了拆分，部署到了一些由网络连接的节点上，共同协作完成原本的功能。</p><p>讲到这里，可能需要和我们现在经常提到的微服务做一些区分。我们现在说到的微服务，是不是分布式的呢？可能是，也可能不是。我们这里提到的分布式，更倾向于有状态的服务，也就是服务和服务之间的依赖关系会更强，数据同步会更紧密。而不是像无状态服务那样，程序可以随意扩展和消亡。</p><p>好，回到正题，就像俗话说的：知易行难，使应用程序可靠、可扩展或可维护并不容易。</p><p>我们接下来逐步分析一下。</p><h3 id="数据复制"><a href="#数据复制" class="headerlink" title="数据复制"></a>数据复制</h3><p>上一节我们提到，我们探讨的更多是有状态程序，状态是通过什么来体现的呢？对了，数据。所以，我们面临的第一个问题就是数据如何在各个节点上同步（复制）的问题。</p><p><code>主从复制</code>应该是你首先能想到的：<code>所有的客户端写入操作都发送到某一个节点(主节点)，由该节点负责将数据更改事件发送到其他副本(从节点)。每个副本都可以接收读请求，但内容可能是过期值</code>。</p><p>主从复制是非常流行的，主要是因为它很容易理解，也不需要担心冲突问题。复制可以是同步的，也可以是异步的，而一旦发生故障，二者的表现差异会对系统行为产生深远的影响。从性能上来说在系统稳定状态下异步复制是优秀的。</p><p>那主从复制有些什么问题呢？主要问题就是<code>写是一个单点</code>，因为写只能写到主节点上，所以，如果主挂了，那么系统就不能再接受写的请求。另外，如果写的请求量很大，那么复制有可能会滞后，造成主从节点间数据不一致的问题。</p><p>怎么解决这两个问题呢？</p><p>解决写单点的问题，其实有两个方案：</p><p><code>多主节点复制</code>：系统存在多个主节点，每个都可以接收写请求，客户端将写请求发送到其中的一个主节点上，由该主节点负责将数据更改事件同步到其他主节点和自己的从节点。通常这个方案主要运用在跨数据中心的数据复制，因为数据中心间的网络实在抖动太厉害。</p><p><code>无主节点复制</code>：客户端将写请求发送到多个节点上，读取时从多个节点上并行读取，以此检测和纠正某些过期数据。Cassandra就是采用的这种架构。这里面要解决的就是如何定义写成功和读成功，里面的Quorum的设置就是比较关键的。</p><p>在这里，我们先暂时不讨论主挂了重新选主的问题，这个话题后面我们再讨论。</p><p>解决复制滞后的问题，这个就没那么简单了，<code>这是一个权衡的问题</code>。</p><p>如果采用<code>同步复制</code>，那么就可以完全解决滞后的问题，但是写入的性能会下降非常快。</p><p>如果采用<code>异步复制</code>，那么滞后就一定会存在，问题就变成你对一致性的要求高不高。如果要求不高，允许一定时间的滞后，那么就没什么问题。如果要求很高，那么可以采用一个办法，读自己的写。什么意思？通俗来说，读写都从主节点进行。当然，这就失去了可扩展性。还有一种办法，就是在客户端上下文章，客户端在读取数据时，记录一下版本或者时间戳，如果下一次再次读取同一条数据时，版本更低，那就认为没有读取成功，这样可以避免读取到旧数据的问题。</p><p>所以你看，针对复制滞后问题，没有一个一概而论的方法，而是根据实际的场景来进行选择。</p><p>主从就说到这里。</p><p>在主从架构之后，大家遇到一个问题，当数据量上升到很大时，所有节点都保存同样的数据，其实依然会达到单个节点的存储上限，所以，不管读还是写，性能都会下降比较快。怎么办？答案是做<code>数据分区：将同一份数据按照一定的规则分布到不同的节点上</code>。</p><p>这里的潜台词就是：不管读还是写，我都需要先计算一下要去哪个分区操作。那么规则就显得比较重要，通常有两种分区方式：</p><p><code>基于关键字区间的分区</code>。先对key进行排序，每个分区只负责一段包含最小到最大关键字范围的一段key。对key排序的优点是可以支持高效的区间查询，但是如果应用程序经常访问与排序一致的某段key，就会存在热点的风险，例如用时间做key。</p><p><code>哈希分区</code>。将哈希函数作用于每个key，每个分区负责一定范围的哈希值。这种方法打破了原key的顺序关系，它的区间查询效率比较低，但可以更均匀地分配负载。</p><p>目前的Nosql，大部分是key-value类型的数据库，所以，基本上天然就可以很好的支持数据分区。而在传统关系型数据库中，这个就会面临一个问题，如何做join？如何做排序？这个时候就需要二级索引的支持，甚至需要一个数据访问中间层的存在。</p><p>当然，分区架构也会面临节点失效的问题，所以，任何分片其实都需要有副本，当主分片所在节点故障时，数据才不会丢失。</p><h3 id="容错问题"><a href="#容错问题" class="headerlink" title="容错问题"></a>容错问题</h3><p>我们前面说过，分布式架构主要解决单台的单点问题，所以我们把程序部署到了多个节点上。</p><p>但是，其实这样情况就复杂了。单台虽然又单点问题，但是挂了就挂了，不会存在其他状态，程序重启后就可以继续挂之前的工作。</p><p>在分布式里，有多个节点了，那么就会出现<code>部分失效</code>的情况。注意，我说的是失效，因为失效不一定是挂了，有可能有下面集中情况：</p><ul><li>网络延迟或者丢包</li><li>机器间时间不一致（有些情况时间非常重要，例如很多产品是靠时间来做最终一致的）</li><li>程序真挂了</li></ul><p>当然，虽然情况多样，但是我们分布式不就是要通过多台来解决可靠性吗？那么我们的设计就要容忍部分失效的发生。并且大家要做好随时发生的准备。</p><p>为了容忍错误，第一步是<code>检测错误</code>，最常见的做法就是维持节点间的一个<code>心跳</code>，但即使这样也很有挑战。心跳不是检测节点是否发生故障的准确机制，大部分场景，我们会设定一个心跳的超时时间，依靠超时来确定远程节点是否仍然可用。但是，<code>超时无法区分网络和节点故障</code>。然而，当某个节点的网络突然拥塞的时候，心跳可能一会有一会没，面对这样一个处于“残废”的节点比彻底挂掉的故障节点更难处理。</p><p>检测到错误之后，让系统容忍失效也不容易。在典型的分布式环境下，没有全局变量，没有共享内存，没有约定的尝试或其他跨节点的共享状态。节点甚至不太清楚现在的准确时间，更不用说其他更高级的了。信息从一个节点流动到另一个节点只能是通过不可靠的网络来发送。<code>单个节点无法安全的做出任何决策，而是需要多个节点之间的共识协议，并争取达到法定票数</code>。</p><p>看到这里，你会发现出错是分布式的常态，而容错并不那么容易。所以，<code>如果单台能解决的问题，尽量不要变成分布式</code>。当然，也不用难过，我们基本上不会重头写一个分布式系统，基本上都有现成的解决方案来解决这些问题。</p><p>这里顺便说一下CAP理论，大家可能都知道这个理论，它说的是：<code>一致性、可用性、分区容错性</code>，任何分布式系统只能支持其中的两个特性。</p><p>但是，网络分区不管你喜欢还是不喜欢，它都一定会存在，这是不能逃避的问题。所以，CAP理论可以换一个说法：<strong>当出现网络分区时，你选择一致性还是可用性？</strong></p><h3 id="共识问题"><a href="#共识问题" class="headerlink" title="共识问题"></a>共识问题</h3><p>有了前面知识的铺垫，可以来简单谈一下<code>共识问题</code>了。</p><p>开篇提到的Skyler同学分享的Raft算法，其实就是一个共识算法。</p><p>那么共识算法要解决分布式的一个什么问题呢？</p><p>上一篇我们说了，分布式就是一个容易发生部分失效的系统，那么要在这样的环境中进行协作，怎么才能高效可靠的进行呢？</p><p>当然，讲到这里，要解释一下，什么类型的工作才是协作。之前我们说的数据复制，其实不算哈。</p><p>我们熟悉的分布式锁、分布式事务之类的，都属于协作的范围，他们的特点就是：<code>一个人提议，大多数人同意，达成一致</code>。</p><p>举个生活中的例子：今天周六，我提议咋们团队中午去吃李庄，team中Lon同意，Victor同意，Skyler同意，Tipo嫌档次低了，但是无奈，少数服从多数我们还是去吃了。这就是共识问题。</p><p>当然，这也不足以说明我们需要研发一个巨复杂的算法，因为这个场景更像一个民主选举的场景，而现实世界中还有另外一个方法达成一致：<code>独裁</code>。</p><p><code>如果系统只存在一个节点，或者愿意把所有决策功能都委托给某一个节点，那么事情就变得很简单</code>。这和主从复制数据库的情形是一样的，即由主节点负责所有的决策事宜。</p><p>然而，如果主节点挂了怎么办？有三种解法</p><ul><li>大家一起等主节点恢复。</li><li>人工介入指定一个主节点。</li><li>自动选举一个主节点。</li></ul><p><code>共识算法在大部分（不是全部哦）的场景下，主要用来解决主从系统中，自动选主的场景</code>。因为有了主节点，我们大部分需要决策的工作，都可以交给主节点来负责。</p><p>那么，反过来想，那些无主系统或者多主系统，是不支持共识的。</p><p>业界比较知名的共识算法就是：<code>Paxos（zookeeper采用）和Raft（ETCD采用）了</code>，这里我不准备花很大篇幅去讲解算法本身，因为随便网上一搜都有很多这方面的文章。</p><p>但是，大家要了解，<code>像zookeeper这类的工具，实际上已经把共识服务做了非常好的封装抽象</code>，假如你遇到共识性问题的场景，那么请不要犹豫，直接用他们即可，毕竟他们是已经验证过的工具。强烈不推荐自己重头造一个轮子。</p><p>好，花了一点时间，带大家捋一下分布式，没有什么太高深的知识，就是希望大家能知道里面的来龙去脉，希望对大家有帮助。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上次团队内部分享，Skyler同学分享了Raft算法，分享过程中，大家还激烈讨论了一下。说明大家其实对分布式系统的原理和实现还是比较感兴趣的。&lt;/p&gt;
&lt;p&gt;当然，我们不是搞科研的，平时工作中可能用不到这些高大上的知识。不过，如果我们能对这些原理性的东西有一个正确的理解，至少能在平时工作中做技术选型时有一个正确的选择。&lt;/p&gt;
&lt;p&gt;所以，今天我想尝试给大家梳理一下分布式系统中涉及到的一些概念和原理，不会太深入，就算给大家做一个提纲挈领的资料吧，希望你看过后能对分布式系统有一个整体的了解吧。&lt;/p&gt;</summary>
    
    
    
    <category term="深入理解" scheme="https://jamesyyang.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    
    
    <category term="分布式" scheme="https://jamesyyang.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>KPI还是OKR</title>
    <link href="https://jamesyyang.github.io/2021/12/03/thinking-kpi-or-okr/"/>
    <id>https://jamesyyang.github.io/2021/12/03/thinking-kpi-or-okr/</id>
    <published>2021-12-03T04:44:21.000Z</published>
    <updated>2023-01-28T04:47:49.459Z</updated>
    
    <content type="html"><![CDATA[<p>绩效管理是任何略有规模的公司都绕不开的话题。</p><span id="more"></span><p>有人说KPI已经过时，现在是OKR的时代；也有人说KPI适合传统企业，OKR适合互联网公司。</p><p>但是我想问问，不管OKR还是KPI，到底要解决一个什么问题？难道就为了年底给员工评一下分，然后确定一下年终奖和晋升机会？</p><p>我觉得不是。</p><p>在我看来，这两个东西没有什么本质的不同，<strong>他们的本质都是企业去管理目标的方法</strong>。</p><p>要管理目标，首先就是要有目标，并且企业里所有人都知道并理解这个目标。</p><p>所以创业公司一般不玩okr或者kpi，因为人太少，团队规模处于老板的管理能力内，他能把目标清晰的传递到每个人头脑里。</p><p>随着企业的规模逐步增加，团队数量也在增加，老板不可能再管理所有人，只能为每个团队设立主管，然后老板管理团队主管。</p><p>我们假设老板是可以将目标清晰传递给各个主管，但是各个主管是否可以传递给一线员工呢？答案是不能，因为信息在传递过程中一定是会有失真的。并且这个失真随着信息经过的节点数量成正比关系。这个道理，玩过动作传递游戏的人都能明白。</p><p>读到这里你可能会问，为什么一线员工需要知道企业的目标？知道自己该干什么不就好么？</p><p>每个员工都能清晰知道自己该干什么，并且目标达成后，企业就能达成目标，这个情况有可能存在。前提是企业的目标非常清晰和简单，并且企业对于分解这样的目标非常熟练，属于显而易见的问题。</p><p>这个情况在传统制造业里是容易实现的，每条流水线生产多少零件，最终能出多少成品，这都是可以量化的。</p><p>所以，这样的企业，组织架构层次通常比较深，通过一些可量化的目标，信息可以在各级员工间传递下去。</p><p>不过，进入信息化时代后，市场开始变得瞬息万变，企业的目标开始变得不那么清晰，且易变。这样的信息在组织架构里传递时，失真得更厉害了。大家开始意识到，组织架构应该尽量扁平，这样信息传递的节点可以大大降低，失真的稍微不那么厉害。</p><p>写到这，我想说的是，目标管理在现代企业里，<strong>最大的难点是如何让目标清晰的在组织内部传递，并且大家保持尽量相同的理解</strong>。而这个问题的解决，和企业的组织架构是息息相关的，反而和你用什么方法，OKR还是KPI没什么关系。</p><p>提到组织架构，又不得不放一张经典的图上来：</p><img src="/images/thinking-1.png" class="" width="500"><p>图中哪个企业的信息传递会更有效率呢？</p><p>这个图也经常被倡导微服务的人用来论述企业如果使用微服务，那么组织架构也应该做出适当的调整。因为微服务是应弹性而生，如果背后的团队还是烟囱式的，那么这样一定是假的微服务。</p><p>最后说一下企业愿景。企业的愿景有没有用？其实是有用的，这是一个企业的终极目标，类似信仰一样。对于这样的目标，一定要简单而伟大且朗朗上口。</p><p>愿景可以让所有员工在没有目标时，提供给他一个指引的方向，让他作出的判断和决策不至于偏差太大。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;绩效管理是任何略有规模的公司都绕不开的话题。&lt;/p&gt;</summary>
    
    
    
    <category term="随想杂谈" scheme="https://jamesyyang.github.io/categories/%E9%9A%8F%E6%83%B3%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="管理" scheme="https://jamesyyang.github.io/tags/%E7%AE%A1%E7%90%86/"/>
    
    <category term="KPI" scheme="https://jamesyyang.github.io/tags/KPI/"/>
    
    <category term="OKR" scheme="https://jamesyyang.github.io/tags/OKR/"/>
    
  </entry>
  
  <entry>
    <title>变现你的冗余能力</title>
    <link href="https://jamesyyang.github.io/2021/10/28/thinking-selling-redundancy/"/>
    <id>https://jamesyyang.github.io/2021/10/28/thinking-selling-redundancy/</id>
    <published>2021-10-28T04:44:21.000Z</published>
    <updated>2023-01-28T04:55:04.698Z</updated>
    
    <content type="html"><![CDATA[<p>我们经常会思考这样的问题：</p><ul><li>作为个人如何开展一下自己的副业？</li><li>作为一个公司如何发掘一项新业务？<span id="more"></span>今天从一个角度来谈一下这个问题：<strong>冗余能力</strong>。</li></ul><p>什么是冗余能力？简单来说就是：<code>我们应对某种事情的能力很强，除了日常处理外，还有很多冗余</code>。</p><p>举个栗子。</p><p>作为码农，我写代码的能力很强，完成日常工作很轻松，甚至每天还有很多空闲时间没有代码可写！</p><p>作为一个家庭成员，我做菜的能力很强，完成一日三餐很轻松，甚至每天还想多做几个菜，但是可惜吃不下！</p><p>……</p><p>大家明白了吧？所以，如果你发现你有这样的冗余能力，那么在这样一个互联网时代，你可以考虑<code>变现它</code>。</p><p>你代码能力很强，可以考虑去接点私活，可以考虑去加入开源组织。</p><p>你的做菜能力很强，可以考虑去做美食播主。</p><p>你的写文章能力很强，可以考虑去做自媒体。</p><p>你的情商很高，可以考虑做情感主播。</p><p>所以，<code>要如何挖掘你的副业，从审视自我的冗余能力开始</code>。</p><p>对于一个公司来说，道理也是一样的。</p><p>大家都熟悉的例子，亚马逊的云业务是怎么产生的？其实很简单，就是为了解决它核心业务当中的一个特别大的难题，那就是在类似于“黑色星期五”，也就是相当于我们中国的“双十一”这样的流量高峰期如何不宕机，而且要保持很好的客户体验。怎么办呢？那就要扩容，支持它运行的整个网络服务、软硬件，尤其是后台在云端的这些用来处理数据、存储数据的设备要足够地强大。</p><p>可是问题来了。对于阿里来说，“双十一”过去以后，它拥有的这样一种超出常态很多的产能就变成了冗余产能。那怎么办？就必须要找到一个途径，把这些冗余能力变现为收入。</p><p>亚马逊就鼓励一些中小企业来使用它的云服务。它本来是为了在自己的网络平台上运行自己公司的业务，这就是最初的云服务。而当一些企业用户觉得很好的时候，这个市场也就起来了，所以今天这个如此强大的业务，是从它既有的业务当中潜滋暗长出来的。</p><p>再举一个例子，就是美团。美团主要的业务就是送餐。对于美团来说，就存在着这样一个问题，中午或者下午的6、7点钟这个时间段，它的系统就会明显地感受到运行的压力，可能就会出现人手不够。只要业务量变大，用户的体验就会下降。</p><p>它为了优化这种客户体验，就必须要将它后台的支撑系统，包括它前台的这些骑手，打造得足够强大。但是，问题又来了，这些都是需要成本的。当高峰期过后，这些骑手们能干的事情就很少了，这就叫冗余能力。</p><p>对于美团来说，它必须要解决这个问题，将它的冗余产能变现为另外的业务。它只需要找到一个场景，它的客户不仅仅只是吃饭，还要干活。比如他们要取文件，他们吃到了一种水果很好吃，要送到朋友的家里去，等等。美团就可以把它既有的产能变现为另外的业务，比如说跑腿的业务。</p><p><code>所以，当我们看到一些大厂去扩展自己的业务边界的时候，与其说它们是有意识地去扩张，不如说是它们的业务如何去消化已经变得非常强大的冗余能力。这也可以叫做箭在弦上，不得不发</code>。</p><p>读到这里，不知道你发现你的冗余能力在哪了吗？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们经常会思考这样的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作为个人如何开展一下自己的副业？&lt;/li&gt;
&lt;li&gt;作为一个公司如何发掘一项新业务？</summary>
    
    
    
    <category term="随想杂谈" scheme="https://jamesyyang.github.io/categories/%E9%9A%8F%E6%83%B3%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="增长" scheme="https://jamesyyang.github.io/tags/%E5%A2%9E%E9%95%BF/"/>
    
  </entry>
  
  <entry>
    <title>每个开发者都应该知道的5条定律</title>
    <link href="https://jamesyyang.github.io/2021/08/12/thinking-5-laws/"/>
    <id>https://jamesyyang.github.io/2021/08/12/thinking-5-laws/</id>
    <published>2021-08-12T04:44:21.000Z</published>
    <updated>2023-02-04T04:00:00.920Z</updated>
    
    <content type="html"><![CDATA[<p>每个开发者都应该知道的5条定律</p><span id="more"></span><h3 id="Murphy-定律"><a href="#Murphy-定律" class="headerlink" title="Murphy 定律"></a>Murphy 定律</h3><blockquote><p>“If anything can go wrong, it will.”<br>“如果有什么事情可能出错，那就一定会出错。”</p></blockquote><p>老杨点评：设计系统一定要健壮，即使在成本考量下暂时不能做到健壮，也需要有灾备方案，也就是传说中的Plan B。</p><h3 id="Knuth-定律"><a href="#Knuth-定律" class="headerlink" title="Knuth 定律"></a>Knuth 定律</h3><blockquote><p>“Premature optimization is the root of all evil (or at least most of it) in programming.”<br>“过早的优化是编程中所有问题(或者至少是大部分问题)的根源。”</p></blockquote><p>老杨点评：优化是需要成本的，过早优化就表示后期变动几率非常大，一旦变动了，优化的成本就无法收回了。</p><h3 id="North-定律"><a href="#North-定律" class="headerlink" title="North 定律"></a>North 定律</h3><blockquote><p>“Every decision is a trade off.”<br>“每一个决定都是一种权衡。”</p></blockquote><p>老杨点评：项目中我们随时都要做出决策，做出选择，任何选择都是对其他选项的放弃，这些选项我们要记录下来。决定都会犯错，这不可怕，可怕的是我们忘记了当初为什么要做这个决策，还有哪些选项可供我们使用。</p><h3 id="Conway-定律"><a href="#Conway-定律" class="headerlink" title="Conway 定律"></a>Conway 定律</h3><blockquote><p>“Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations.”<br>“系统设计的架构受限于生产设计，反映出公司组织的沟通架构”</p></blockquote><p>老杨点评：组织架构决定系统架构。</p><h3 id="Parkinson-定律"><a href="#Parkinson-定律" class="headerlink" title="Parkinson 定律"></a>Parkinson 定律</h3><blockquote><p>“Members of an organization give disproportionate weight to trivial issues.”<br>“一个组织的成员过分重视琐碎的问题。”</p></blockquote><p>老杨点评：人们更愿意把注意力和观点放在他们熟悉的事物上，而不是复杂的问题上。所以，为什么会议要有一个组织者，主要是确保不跑偏。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;每个开发者都应该知道的5条定律&lt;/p&gt;</summary>
    
    
    
    <category term="随想杂谈" scheme="https://jamesyyang.github.io/categories/%E9%9A%8F%E6%83%B3%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>微信的产品观</title>
    <link href="https://jamesyyang.github.io/2021/07/09/thinking-wechat-product-view/"/>
    <id>https://jamesyyang.github.io/2021/07/09/thinking-wechat-product-view/</id>
    <published>2021-07-09T04:44:21.000Z</published>
    <updated>2023-02-04T01:33:21.927Z</updated>
    
    <content type="html"><![CDATA[<p>本文是《微信背后的产品观》的书摘</p><span id="more"></span><h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><p>用户的反馈只是帮助你了解到他们的想法，而用户的需求是零散的，解决方案是归纳抽象的过程。</p><p>这个理论来自一本书——《乌合之众》。如果我们聚集在一起去做一件事情，那我们就是乌合之众。群体智商必然是不如个体智商的，因为大家都喜欢趋同，向别人看齐。</p><p>之前跟某产品的负责人聊天，说他们的产品口号是“发现新的知识，发现更多的世界”，其实不太对。因为人没有学习知识的爱好，都是被动学习的。假定用户很喜欢学习很喜欢知识，这个出发点可能就错了。</p><p>可以看到，用户的一些心态，很多时候跟我们预想的是不一样的，如果我们把事情一步到位，做细了，可能会出问题。</p><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>所以，需求只来自你对用户的了解，这里非常想强调几点：第一，需求不来自调研；第二，需求不来自分析；第三，需求不来自讨论；第四，需求不来自竞争对手。</p><p>所以，对于新点子，99% 的情况下把它否定掉总是对的。当你要去判定这个点子该不该做的时候，很简单，否定、不做，就可以了。</p><p>情感上的需求，也是产品中除技术以外很重要的一点。伟大的产品应该满足人的情感需求，而不仅是提供一些功利上的好处。</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>对于产品来说，从中受到一个很大的启发是，要营造一个“环境”，然后由这个环境来决定用户来做什么样的反应，用户会被你营造的“环境”牵引。这是决定用户应该做什么的重要因素。</p><p>这句话说明一个问题，就是我们在做产品设计的时候，到底是面向场景来做，还是面向某个功能来做？因为功能脱离了场景是没有意义的。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>如果一个问题的解决方案太复杂，一定是问题本身错了。事实上就是这样的。</p><p>我想跟大家说，其实没有设计，只有解决问题。我们很害怕的一点是，很多人把设计工作想得非常高端，觉得这是一个很高尚的职业。其实我们每天都是在解决问题，而不是从事设计工作，只有把问题解决好了，才是做了一个好的设计，但不是为了去做设计而去解决问题。这是本末倒置的。</p><p>我们做一个产品的时候，结构是最重要的，然后才是一些细节。大家常常会听到这样一句话：“赢在细节”，让人以为把细节做好就可以了，其实不是的。微信是一个值得研究的产品，因为微信里面包含的功能非常多，如果做一个列表把微信的所有功能列出来的话，会发现这是很恐怖的，里面包含的东西特别多。但目前大家用到的微信并没有显得很复杂，看起来还是挺简单的，以至于我们做了一个新版本，你都找不到它有什么新功能。那是因为我们先把微信的骨骼梳理清楚了，枝叶的东西藏得很深也没有关系，这样整个产品才不会乱掉。</p><p>我们说设计就是分类的意思是，我们发现在做很多产品的时候，做得不好往往是分类分得不好，几乎大部分的工作都可以归结到这一点上。哪怕是写一篇简单的文案、一个用户的通知，到怎么去定义一个产品特性，最终都可以归结为分类有没有分得很好。只有分类分得好，对用户才能显得亲切易懂，对产品才显得结构清晰。</p><p>因为我们做新功能的时候，总是喜把新功能摆出来，总是怕用户不知道我们做了什么新功能。这都是新手的做法。</p><p>新功能的罗列是坚决不可接受的，是极端不好的。我记得苹果以前的发布会，是不会罗列一堆功能指标、一堆性能指标的，但是现在开始罗列一些指标了，感觉这是不好的趋势。苹果的产品买的是整体的体验，</p><p>所以我们认为，好的产品应该是自然增长的，而不应该为KPI而改变产品。KPI只是一个好产品的副产品，好的产品自然会产生好的增长曲线。</p><p>所以说，战略行为不一定来自需求层面，更多来自战略任务，战略任务可能放在任何一个时代都成立，但是在真实场景下不一定成立。所以我们看到很多大公司，它的战略很厉害，但是最终还是走向失败。</p><p>有DNA的产品才会进化。DNA到底是什么东西呢？DNA是产品的价值观和认知，产品在进化的过程中，怎么才能看起来像个生物体那样，有自己的内在？这些都是我们在不断思考的问题。</p><p>如果我们非要用一个词来表达一个产品有灵魂的话，它应该像人一样，有很多面。它是有机联系的，表现出的产品结构是很好的；它有肌肉的东西，是功能；有产品的气质，背后是价值观；它的反应应该很敏捷，应该很理性；它的理性表现在逻辑很清晰、交互很合理上；它的谈吐(文案)要好。对应到人身上，它是整体和谐而不是精神分裂的。</p><p>当我们可以跳出非常功利的目标之外，再想一下初心，重新用另外的角度来看我们的产品，可能你会觉得你的工作会变得很有乐趣，充满了挑战，并且很有成就感。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文是《微信背后的产品观》的书摘&lt;/p&gt;</summary>
    
    
    
    <category term="随想杂谈" scheme="https://jamesyyang.github.io/categories/%E9%9A%8F%E6%83%B3%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>乱谈秒杀</title>
    <link href="https://jamesyyang.github.io/2020/10/04/deep-seckill/"/>
    <id>https://jamesyyang.github.io/2020/10/04/deep-seckill/</id>
    <published>2020-10-04T04:54:04.000Z</published>
    <updated>2023-05-04T03:30:44.702Z</updated>
    
    <content type="html"><![CDATA[<p>最近，公司一直在搞秒杀，当然，过程中还是出了很多问题，随便在confluence搜索一下都能看到。</p><p>我也来谈一下秒杀吧，当然，我自己谈这个话题也不专业，权当纸上谈兵吧。</p><span id="more"></span><h2 id="什么是秒杀"><a href="#什么是秒杀" class="headerlink" title="什么是秒杀"></a>什么是秒杀</h2><p>在谈秒杀前，首先要搞清楚，什么是秒杀。</p><p>简单来说，秒杀就是在同一个时刻有大量的请求争抢购买同一个商品并完成交易的过程。</p><p>这个解释是对用户的。对技术人员来说，<code>秒杀就是在同一时刻有大量的并发读和并发写</code>。</p><p>那么，按照这个思路来看一个好的秒杀系统具备的特征就应该是：</p><ul><li>在大量并发读的情况下，没挂，且响应很快。</li><li>在大量并发写的情况下，没挂，且保证数据一致。</li></ul><p>所以，本质上来说<code>秒杀系统就是一个满足大并发、高性能和高可用的分布式系统</code>。</p><p>下定义都是很简单的，但是做起来确是很难的。因为并发问题，通常都是困扰程序员的一大难题。</p><p>那么，不管是哪种技术平台，哪种架构方式，我认为在设计秒杀系统的时候，可能都需要考虑以下一些设计原则：</p><ul><li>数据尽量少：不管是用户请求的数据，还是服务器回传的数据，都要尽量少。因为数据量大了，首先占用网络带宽，同时网络传输时间也会加长。再一个，网络传输通常都是加密的，数据量大，CPU占用也会增加。</li><li>请求数尽量少：请求数多了，对socket的占用是非常大的，这会带来两个问题：如果是客户端请求，那么通常请求数会受浏览器限制；如果是内部服务间的请求，大量的TCP建立，三次握手，开销也很大。</li><li>路径尽量短：路径是指从客户请求开始，到接到响应，中间经过的环节，包括经过了netscaler，api gateway，各个微服务等。每个环节都有可能不稳定，所以，多一个环节就多一个不确定因数。</li><li>依赖尽量少：这个就不用多解释了，如果一个秒杀系统依赖的系统或者服务过多，那么拖垮这个系统的有可能是一些不必要的依赖。</li></ul><p>好，接下来就尝试讨论一下如何来做好秒杀。</p><h2 id="分"><a href="#分" class="headerlink" title="分"></a>分</h2><p>这一章的标题叫做分，意味着我们要尝试分离一些东西。</p><p>我们现在的秒杀就是在已有的系统上进行的，只是这些秒杀商品是在特定的时间才能看到库存而已，当库存卖完了也就结束了。</p><p>但是随着访问量的增加，瓶颈很快就会显现，我们需要进行有针对性的架构优化。但是既然是有针对性的，我们可能就无法在现有系统上来做，因为现有系统可能是一个庞大的，依赖关系很多的复杂产物。按照我上一篇提到的几个原则，很可能是不满足的。</p><p>所以，第一个要分的就是：把<code>秒杀系统分离出来单独打造一个系统</code>，这样可以有针对性地做优化。并且在系统部署上也独立做一个集群。这样秒杀的大流量就不会影响到正常的商品购买集群的机器负载。</p><p>有了独立系统后，我们就可以大刀阔斧的优化了，优化方式可以参照上一篇提到的原则，例如尽量少请求，少传输数据等。</p><p>第二个要分离的就是<code>动静分离</code>。这个比较好理解，静态内容比如html，js，css等等，这些内容要放得离用户越近越好。常见的位置，例如浏览器里、CDN和服务端缓存。</p><p>第三个要分离的就是<code>冷热数据</code>。秒杀商品是一个典型的热点商品，它们在很短时间内被大量用户执行访问、添加购物车、下单等操作，这些操作我们就称为“热点操作”。因为是我们自己在掌控秒杀，所以热点商品是可以提前预知的，那么对于热点数据就要做提前的缓存，能不去操作数据库的就不要去操作，甚至库存扣减都可以放到缓存里来做。</p><h2 id="削"><a href="#削" class="headerlink" title="削"></a>削</h2><p>削什么？看下图：</p><img src="/images/seckill-1.png" class="" width="400"><p>这是前两天秒杀的流量监控图，你会发现请求在秒杀开始的瞬间增加的很多。这是因为秒杀请求在时间上高度集中于某一特定的时间点。这样一来，就会导致一个特别高的流量峰值，它对资源的消耗是瞬时的。</p><p>但是对秒杀这个场景来说，最终能够抢到商品的人数是固定的，也就是说100人和10000人发起请求的结果都是一样的,并发度越高，无效请求也越多。</p><p>但是从业务上来说，秒杀活动是希望更多的人来参与的，也就是开始之前希望有更多的人来刷页面，但是真正开始下单时，秒杀请求并不是越多越好。因此我们可以设计一些规则，让并发的请求更多地延缓，而且我们甚至可以过滤掉一些无效请求。</p><p>这就是削峰的意义所在：一是可以让服务端处理变得更加平稳；二是可以节省服务器的资源成本针对秒杀这一场景。削峰从本质上来说就是更多地延缓用户请求的发出，以便减少和过滤掉一些无效请求。</p><p>怎么削？</p><h3 id="排队"><a href="#排队" class="headerlink" title="排队"></a>排队</h3><p>要对流量进行削峰，最容易想到的解决方案就是用消息队列来缓冲瞬时流量，把同步的直接调用转换成异步的间接推送,，中问通过一个队列在一端承接瞬时的流量洪峰，在另一端平滑地将消息推送出去。在这里，消息队列就像“水库”一样，拦著上游的洪水，削减进入下游河道的洪峰流量，从而达到减免洪水灾害的目的。</p><img src="/images/seckill-2.png" class="" width="400"><p>实际上，排队就是把“一步的操作”变成“两步的操作”，其中增加的一步操作用来起到缓冲的作用。但是呢，这会引入新的调用环节，不符合“请求尽量少”的原则，所以这是为了不让系统奔溃的一个妥协。</p><h3 id="答题"><a href="#答题" class="headerlink" title="答题"></a>答题</h3><p>答题实际上就是我们俗称的“验证码”，例如：</p><img src="/images/seckill-3.png" class="" width="400"><p>这主要是为了增加购买的复杂度，从而达到两个目的。</p><p>第一个目的是防止部分买家使用机器人在参加秒杀时作弊。所以系统增加了答题来限制机器人。增加答题后，下单的时间基本控制在2s后，机器人的下单比例也大大下降。</p><p>第二个目的其实就是延缓请求，起到对请求流量进行削峰的作用,从而让系统能够更好地支持瞬时的流量高峰。这个重要的功能就是把峰值的下单请求拉长，从以前的1s之内延长到2s-10s。这样一来请求峰值基于时间分片了。这个时间的分片对服务端处理并发非常重要，会大大减轻压力。而且，由于请求具有先后顺序，靠后的请求到来时自然也就没有库存了，因此根本到不了最后的下单步骤，所以真正的并发写就非常有限了。</p><h3 id="边缘计算"><a href="#边缘计算" class="headerlink" title="边缘计算"></a>边缘计算</h3><p>理论上我们一定会用上 CDN。然后，我们还需要在这些 CDN 结点上做点小文章。</p><p>一方面，我们需要把小服务部署到 CDN 结点上去，这样，当前端页面来问开没开始时，这个小服务除了告诉前端开没开始外，其还会做一下有多少人在线的一个统计。每个小服务会把这当前在线等待秒杀的人数每隔一段时间就回传给我们的数据中心，于是我们就知道全网总共在线的人数有多少。</p><p>假设，我们知道有大约 100 万的人在线等着抢，那么，在我们快要开始的时候，由数据中心向各个部署在 CDN 结点上的小服务上传递一个概率值，比如说是 0.02%。于是，当秒杀开始的时候，这 100 万用户都在点下单按钮时，首先请求到的是 CDN 上的这个小服务，这个小服务按照 0.02% 的量把用户放到后面的数据中心，也就是 1 万个人放过去两个，剩下的 9998 个都直接返回秒杀已结束。</p><p>于是，100 万用户被放过了 0.02% 的用户，也就是 200 个左右，而这 200 个人在数据中心抢那 100 个 iPhone，也就是 200 TPS，这个并发量怎么都应该能扛住了。</p><h2 id="扣"><a href="#扣" class="headerlink" title="扣"></a>扣</h2><p>做一个秒杀系统，最重要的一点就是：<code>别超卖</code>。</p><p>所以，扣减库存不是一个简单的事情，不能卖多，也不能卖不完。这其中有一个问题很关键：什么时候扣减库存？你说系统是用户下单了就算这个商品卖出去了，还是等到用户真正付款了才算卖出了呢？</p><p>下面我们就来看看这其中的区别，当然，这篇应该让 Eric Tan来写的，他应该是专家哈，hot item就是干这个事情的。我先班门弄斧了。</p><p>在正常的电高平台购物场景中,用户的实际购买过程一般分为两步：下单和付款。你想买一台iphone 手机,在商品页面点了“立即购买”按钮，核对信息之后点击“提交订单”，这一步称为下单操作。下单之后，你只有真正完成付款操作才能算真正购买，也就是俗话说的“落袋为安”</p><p>那如果你来设计系统，你会在哪个环节完成减库存的操作呢？总结来说，减库存操作一般有如下几个方式：</p><ul><li>下单减库存，即当买家下单后，在商品的总库存中减去买家购买数量。下单减库存是最简单的减库存方式，也是控制最精确的一种，下单时直接通过数据库的事务机制控制商品库存，这样一定不会出现超卖的情况。但是你要知道，有些人下完单可能并不会付款。所以，如果有人恶意下单，下完后不付款，会导致无法正常销售商品。</li><li>付款减库存，即买家下单后，并不立即减库存，而是等到有用户付款后才真正减库存，否则库存一直保留给其他买家。但因为付款时才减库存，如果并发比较高，有可能出现买家下单后付不了款的情况，因为可能商品已经被其他人买走了。所以，并发高的时候会出现超卖。</li><li>预扣库存，这种方式相对复杂一些，买家下单后，库存为其保留一定的时间（如10分钟)，超过这个时间，库存将会自动释放，释放后其他买家就可以继续购买。在买家付款前，系统会校验该订单的库存是否还有保留：如果没有保留，则再次尝试预扣；如果库存不足（也就是预扣失败）则不允许继续付款；如果预扣成功，则完成付款并实际地减去库存。</li></ul><p>针对这三种方式，秒杀应该用哪种扣减呢？我认为应该用下单减库存。原因是，因为不能超卖，所以付款减不适合。另外，秒杀可能时间很短就结束了，用预扣没必要，等保留时间过了，估计秒杀都完了。</p><p>我们可以用一些业务手段或者技术手段来过滤恶意下单，所以，综合来看还是应该用下单减库存。</p><p>剩下就是怎么扣的问题，秒杀商品的库存绝对是一个热点数据，所以<code>能在缓存扣就一定不要去数据库扣</code>。</p><p>如果万不得已一定要去数据库扣，怎么破？削峰，把大部分请求过滤掉，大大降低最后去数据库扣减的量。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>好，简单探讨了一下秒杀的一些东西，写得有点乱，希望你没看晕。</p><p>当然，是不是做好了这几点就一定能做一个成功的秒杀？答案是不一定，因为没人可以预判到真实的情况，所以我们一定需要有一套运维的方案来应对各种情况。</p><ul><li>降级：关闭一些系统的非核心功能，把资源留给更核心的业务去用。</li><li>限流：限流是为了保护系统不奔溃，让一些请求失效。当然，前提是我们清楚的知道我们系统的承载量，这样设置的限流阈值才会更合理。</li><li>Plan B：如果以上措施都还是没有保护好我们的系统，最终还是崩了的话，我们需要有一个备用方案来兜底。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近，公司一直在搞秒杀，当然，过程中还是出了很多问题，随便在confluence搜索一下都能看到。&lt;/p&gt;
&lt;p&gt;我也来谈一下秒杀吧，当然，我自己谈这个话题也不专业，权当纸上谈兵吧。&lt;/p&gt;</summary>
    
    
    
    <category term="深入理解" scheme="https://jamesyyang.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    
    
    <category term="分布式" scheme="https://jamesyyang.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="秒杀" scheme="https://jamesyyang.github.io/tags/%E7%A7%92%E6%9D%80/"/>
    
  </entry>
  
</feed>
